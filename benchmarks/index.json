{"project": "probnum", "project_url": "https://probabilistic-numerics.github.io/probnum/intro.html", "show_commit_url": "http://github.com/probabilistic-numerics/probnum/commit/", "hash_length": 8, "revision_to_hash": {"326": "1e88aa702d15c75e59e01780ce8fe36e4f414813", "512": "27fdbf1ff795f7d37f113377d34be65f16e79841", "513": "9f55a206eec6ba4cbdca6c5216282992a8859dc4", "514": "7c45c6ebb2224b2c12ef190c661d2aeefb56af05", "515": "438021a2dda54af9abad7d48cf0daba33e5f566d", "516": "22f54fab6cb9638a000fa1b8733176271618bb99", "517": "762b2f7fcb6411e011b240d4ae1ce2a751741c5a", "518": "92b791168d0f1bc3c484a1ac48ce091991bc23a0", "519": "50c57740667c4245b2faa02698837375458be061", "520": "9c53fec41dcc1145d6e22f7f0b917d247455f112", "521": "95e4a72752369ca913160c5d01b85e4f0ffaac30", "523": "5d329650e9d57074536a964512cbd8aedc133bd6", "529": "055b25575e23682ef8906975f8959d9a62a16385", "531": "c021be89c7f645ae3bf48c6b339773f890f287fe"}, "revision_to_date": {"326": 1593794977000, "512": 1595520202000, "513": 1595520474000, "514": 1595520520000, "515": 1595521887000, "516": 1595529249000, "517": 1595529342000, "518": 1595529368000, "519": 1595529437000, "520": 1595529476000, "521": 1595529716000, "523": 1595583834000, "529": 1595854429000, "531": 1595950062000}, "params": {"machine": ["cloudrunner"], "python": ["3.8"], "branch": ["master", "development"]}, "graph_param_list": [{"machine": "cloudrunner", "python": "3.8", "branch": "master"}, {"machine": "cloudrunner", "python": "3.8", "branch": "development"}], "benchmarks": {"distribution.Functions.time_distr_functions": {"code": "class Functions:\n    def time_distr_functions(self, dist, property):\n        \"\"\"Times evaluation of the pdf, logpdf, cdf and logcdf.\"\"\"\n        try:\n            if property == \"pdf\":\n                self.randvar.distribution.pdf(x=self.eval_point)\n            elif property == \"logpdf\":\n                self.randvar.distribution.pdf(x=self.eval_point)\n            elif property == \"cdf\":\n                self.randvar.distribution.pdf(x=self.quantile)\n            elif property == \"logcdf\":\n                self.randvar.distribution.pdf(x=self.quantile)\n        except NotImplementedError:\n            pass\n\n    def setup(self, dist, property):\n        self.randvar = get_randvar(distribution_name=dist)\n        self.eval_point = np.random.uniform(self.randvar.shape)\n        self.quantile = np.random.uniform(self.randvar.shape)", "min_run_count": 2, "name": "distribution.Functions.time_distr_functions", "number": 0, "param_names": ["dist", "property"], "params": [["'univar_normal'", "'multivar_normal'", "'matrixvar_normal'", "'symmatrixvar_normal'"], ["'pdf'", "'logpdf'", "'cdf'", "'logcdf'"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "c34be45871a81ba51db14abb809470bf779abec711211d454c4275de8f77a6b4", "warmup_time": -1}, "distribution.Sampling.peakmem_sample": {"code": "class Sampling:\n    def peakmem_sample(self, dist):\n        \"\"\"Peak memory of sampling process.\"\"\"\n        self.randvar.sample(self.n_samples)\n\n    def setup(self, dist):\n        np.random.seed(42)\n        self.n_samples = 1000\n        self.randvar = get_randvar(distribution_name=dist)", "name": "distribution.Sampling.peakmem_sample", "param_names": ["dist"], "params": [["'univar_normal'", "'multivar_normal'", "'matrixvar_normal'", "'symmatrixvar_normal'"]], "timeout": 60.0, "type": "peakmemory", "unit": "bytes", "version": "c75738772ab05552dcec0b653b26eb4397de0c750d14eea3f6e0b1afbf0a8a97"}, "distribution.Sampling.time_sample": {"code": "class Sampling:\n    def time_sample(self, dist):\n        \"\"\"Times sampling from this distribution.\"\"\"\n        self.randvar.sample(self.n_samples)\n\n    def setup(self, dist):\n        np.random.seed(42)\n        self.n_samples = 1000\n        self.randvar = get_randvar(distribution_name=dist)", "min_run_count": 2, "name": "distribution.Sampling.time_sample", "number": 0, "param_names": ["dist"], "params": [["'univar_normal'", "'multivar_normal'", "'matrixvar_normal'", "'symmatrixvar_normal'"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "f20f857be1d0c0f4340e8064e5285dad677a08c3d33aa21133d190a573c4fad8", "warmup_time": -1}, "linearsolvers.LinSolve.mem_solve": {"code": "class LinSolve:\n    def mem_solve(self, system):\n        # Solve linear system\n        self.xhat, self.Ahat, self.Ainvhat, _ = problinsolve(A=self.A, b=self.b)\n\n    def setup(self, system):\n        # Seed\n        np.random.seed(42)\n    \n        if system == \"sparse\":\n            self.A, self.b = load_poisson_linear_system()\n        elif system == \"dense\":\n            self.A = np.array([\n                [2.3, -2.3, 3.5, 4.2, 1.8],\n                [-2.3, 3.0, -3.5, -4.8, -1.9],\n                [3.5, -3.5, 6.9, 5.8, 0.8],\n                [4.2, -4.8, 5.8, 10.1, 6.3],\n                [1.8, -1.9, 0.8, 6.3, 12.1]\n            ])\n            self.b = np.random.normal(size=self.A.shape[0])\n        elif system == \"large-scale\":\n            self.A = None\n            self.b = None", "name": "linearsolvers.LinSolve.mem_solve", "param_names": ["system"], "params": [["'sparse'", "'dense'"]], "timeout": 60.0, "type": "memory", "unit": "bytes", "version": "5f89a23f7f1a2da54cdfdb1304351cff79c2ff2ccbca48a1bc002ab792272dd5"}, "linearsolvers.LinSolve.peakmem_solve": {"code": "class LinSolve:\n    def peakmem_solve(self, system):\n        # Solve linear system\n        self.xhat, self.Ahat, self.Ainvhat, _ = problinsolve(A=self.A, b=self.b)\n\n    def setup(self, system):\n        # Seed\n        np.random.seed(42)\n    \n        if system == \"sparse\":\n            self.A, self.b = load_poisson_linear_system()\n        elif system == \"dense\":\n            self.A = np.array([\n                [2.3, -2.3, 3.5, 4.2, 1.8],\n                [-2.3, 3.0, -3.5, -4.8, -1.9],\n                [3.5, -3.5, 6.9, 5.8, 0.8],\n                [4.2, -4.8, 5.8, 10.1, 6.3],\n                [1.8, -1.9, 0.8, 6.3, 12.1]\n            ])\n            self.b = np.random.normal(size=self.A.shape[0])\n        elif system == \"large-scale\":\n            self.A = None\n            self.b = None", "name": "linearsolvers.LinSolve.peakmem_solve", "param_names": ["system"], "params": [["'sparse'", "'dense'"]], "timeout": 60.0, "type": "peakmemory", "unit": "bytes", "version": "af6eef7ddd7caef365704cfdf46a91503b5d9fb963dac8126745b6ba718b4349"}, "linearsolvers.LinSolve.time_solve": {"code": "class LinSolve:\n    def time_solve(self, system):\n        # Solve linear system\n        self.xhat, self.Ahat, self.Ainvhat, _ = problinsolve(A=self.A, b=self.b)\n\n    def setup(self, system):\n        # Seed\n        np.random.seed(42)\n    \n        if system == \"sparse\":\n            self.A, self.b = load_poisson_linear_system()\n        elif system == \"dense\":\n            self.A = np.array([\n                [2.3, -2.3, 3.5, 4.2, 1.8],\n                [-2.3, 3.0, -3.5, -4.8, -1.9],\n                [3.5, -3.5, 6.9, 5.8, 0.8],\n                [4.2, -4.8, 5.8, 10.1, 6.3],\n                [1.8, -1.9, 0.8, 6.3, 12.1]\n            ])\n            self.b = np.random.normal(size=self.A.shape[0])\n        elif system == \"large-scale\":\n            self.A = None\n            self.b = None", "min_run_count": 2, "name": "linearsolvers.LinSolve.time_solve", "number": 0, "param_names": ["system"], "params": [["'sparse'", "'dense'"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "bc59b7a996dbae83510dbeb7fe6d300304bedfd9fce6b8420b24f84416328c01", "warmup_time": -1}, "linearsolvers.PosteriorDist.time_sample": {"code": "class PosteriorDist:\n    def time_sample(self, output):\n        if output == \"solution\":\n            self.xhat.sample(self.n_samples)\n        elif output == \"matrix\":\n            self.Ahat.sample(self.n_samples)\n        elif output == \"matrix_inverse\":\n            self.Ainvhat.sample(self.n_samples)\n\n    def setup(self, output):\n        # Sparse system\n        self.A, self.b = load_poisson_linear_system()\n    \n        # Solve linear system\n        self.xhat, self.Ahat, self.Ainvhat, _ = problinsolve(A=self.A, b=self.b)\n    \n        # Benchmark parameters\n        self.n_samples = 10", "min_run_count": 2, "name": "linearsolvers.PosteriorDist.time_sample", "number": 0, "param_names": ["output"], "params": [["'solution'", "'matrix'", "'matrix_inverse'"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "e140297042a5ac6c236f00da17a4cb3660a63433fcab0c2f619ef7a57ddfb3d8", "warmup_time": -1}}, "machines": {"cloudrunner": {"machine": "cloudrunner", "version": 1}}, "tags": {"v.0.0.1-alpha": 326, "v0.0.1-beta": 514}, "pages": [["", "Grid view", "Display as a agrid"], ["summarylist", "List view", "Display as a list"], ["regressions", "Show regressions", "Display information about recent regressions"]]}