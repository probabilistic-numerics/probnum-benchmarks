{"project": "probnum", "project_url": "https://probabilistic-numerics.github.io/probnum/intro.html", "show_commit_url": "http://github.com/probabilistic-numerics/probnum/commit/", "hash_length": 8, "revision_to_hash": {"326": "1e88aa702d15c75e59e01780ce8fe36e4f414813", "327": "e72d4fe9ceee2c69a1085408ef42b7db24c26dba", "347": "154982ac630259b85883a26bc5cd33afa898f6b6", "477": "f3403ddb418225f872c7f68d8fa101b4ddeee436", "482": "0765d66cbaefa863a7c6d04f5cf9fe9e4af16d69", "491": "be8d94f92bf40b6e853be0b0c8ce536227b2a6ac", "492": "f6569f439e8c84d4d1297ac80155cc3540b76af4", "493": "54bf5b403b56877af0c48b35596263917dd095c8", "494": "a8b9f55110e96ac6f6b43c0917e371e4128cd75a", "495": "5cadbe43f6446028b4d96520bd6c75702650c4b9", "496": "bd11c04c66622ef58fd196f21079ddec1d60456f", "497": "a8879ffba045bec76808135fead815e8f18d9516", "498": "19e6f9949ebc03174ab5f74dab94c96c64417317", "499": "a6c8c828ccadaa367451b2bf350dcf2be8d580c3", "500": "2fd4b9062884833df0d3360785c5a82ee1c7e9a0", "501": "7135e32367e384a25edc8363de8207f801fff87e", "502": "7d3d3c6563b67f199576e041893c496e0130f9d5", "503": "d4fb68c8d7d4cc86be515ec30d5e8ed901048609", "504": "0260370781a117d7053e8971d908cb385bd396e6", "505": "8529e35ec07bfaec6f8ffb94c37732f41570684d", "506": "54efaf3b49568edee4affa95663e8c0eb14cbc7f", "507": "346cd216f8015964fc57eec23ce111859f8c13fc", "508": "a6e55f9d7411e77f0c7bf4623a9a2c2e80391755", "509": "ba85191dbac4e2e302e8ab704982924164cdd0c3", "510": "92224bfe3a1927a853cf1fc24f3e1f986a4164db", "511": "f3c7158589b091b7baa990b4fb6e2692bb94df80", "512": "27fdbf1ff795f7d37f113377d34be65f16e79841", "513": "9f55a206eec6ba4cbdca6c5216282992a8859dc4", "514": "7c45c6ebb2224b2c12ef190c661d2aeefb56af05", "515": "438021a2dda54af9abad7d48cf0daba33e5f566d", "516": "22f54fab6cb9638a000fa1b8733176271618bb99", "517": "762b2f7fcb6411e011b240d4ae1ce2a751741c5a", "518": "92b791168d0f1bc3c484a1ac48ce091991bc23a0", "519": "50c57740667c4245b2faa02698837375458be061", "520": "9c53fec41dcc1145d6e22f7f0b917d247455f112", "521": "95e4a72752369ca913160c5d01b85e4f0ffaac30", "522": "7e5f297dbad4ee650ef8a60a5bc62f4a30a367bf", "523": "5d329650e9d57074536a964512cbd8aedc133bd6", "524": "00809c2df3003ba89e220de8963f02f9c8b0f222", "525": "bf1f36532abe3698b2f5b1111552f36ed431e4aa", "526": "c52a88a966e88e87c34ed1115dff09e3a02d6a97", "527": "4d7094c26838d530468dc554645060099ae393e4", "528": "1d6839c416091d49d2e2595ac9cda615f6ce0ec9", "529": "055b25575e23682ef8906975f8959d9a62a16385", "530": "350a04e2e1f8327b75b6d6cdc5888c25e87b4403", "531": "c021be89c7f645ae3bf48c6b339773f890f287fe"}, "revision_to_date": {"326": 1593794977000, "327": 1593796173000, "347": 1594191346000, "477": 1595416786000, "482": 1595422140000, "491": 1595430933000, "492": 1595431141000, "493": 1595432129000, "494": 1595429738000, "495": 1595429944000, "496": 1595502966000, "497": 1595502995000, "498": 1595503951000, "499": 1595503980000, "500": 1595504322000, "501": 1595504595000, "502": 1595505107000, "503": 1595505889000, "504": 1595506033000, "505": 1595506451000, "506": 1595506501000, "507": 1595507091000, "508": 1595514273000, "509": 1595515346000, "510": 1595516011000, "511": 1595519885000, "512": 1595520202000, "513": 1595520474000, "514": 1595520520000, "515": 1595521887000, "516": 1595529249000, "517": 1595529342000, "518": 1595529368000, "519": 1595529437000, "520": 1595529476000, "521": 1595529716000, "522": 1595583206000, "523": 1595583834000, "524": 1595593647000, "525": 1595593815000, "526": 1595843297000, "527": 1595849084000, "528": 1595849534000, "529": 1595854429000, "530": 1595947456000, "531": 1595950062000}, "params": {"machine": ["cloudrunner"], "python": ["3.8"], "branch": ["master", "development"]}, "graph_param_list": [{"machine": "cloudrunner", "python": "3.8", "branch": "master"}, {"machine": "cloudrunner", "python": "3.8", "branch": "development"}], "benchmarks": {"distribution.Functions.time_distr_functions": {"code": "class Functions:\n    def time_distr_functions(self, dist, property):\n        \"\"\"Times evaluation of the pdf, logpdf, cdf and logcdf.\"\"\"\n        try:\n            if property == \"pdf\":\n                self.randvar.distribution.pdf(x=self.eval_point)\n            elif property == \"logpdf\":\n                self.randvar.distribution.pdf(x=self.eval_point)\n            elif property == \"cdf\":\n                self.randvar.distribution.pdf(x=self.quantile)\n            elif property == \"logcdf\":\n                self.randvar.distribution.pdf(x=self.quantile)\n        except NotImplementedError:\n            pass\n\n    def setup(self, dist, property):\n        self.randvar = get_randvar(distribution_name=dist)\n        self.eval_point = np.random.uniform(self.randvar.shape)\n        self.quantile = np.random.uniform(self.randvar.shape)", "min_run_count": 2, "name": "distribution.Functions.time_distr_functions", "number": 0, "param_names": ["dist", "property"], "params": [["'univar_normal'", "'multivar_normal'", "'matrixvar_normal'", "'symmatrixvar_normal'"], ["'pdf'", "'logpdf'", "'cdf'", "'logcdf'"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "c34be45871a81ba51db14abb809470bf779abec711211d454c4275de8f77a6b4", "warmup_time": -1}, "distribution.Sampling.peakmem_sample": {"code": "class Sampling:\n    def peakmem_sample(self, dist):\n        \"\"\"Peak memory of sampling process.\"\"\"\n        self.randvar.sample(self.n_samples)\n\n    def setup(self, dist):\n        np.random.seed(42)\n        self.n_samples = 1000\n        self.randvar = get_randvar(distribution_name=dist)", "name": "distribution.Sampling.peakmem_sample", "param_names": ["dist"], "params": [["'univar_normal'", "'multivar_normal'", "'matrixvar_normal'", "'symmatrixvar_normal'"]], "timeout": 60.0, "type": "peakmemory", "unit": "bytes", "version": "c75738772ab05552dcec0b653b26eb4397de0c750d14eea3f6e0b1afbf0a8a97"}, "distribution.Sampling.time_sample": {"code": "class Sampling:\n    def time_sample(self, dist):\n        \"\"\"Times sampling from this distribution.\"\"\"\n        self.randvar.sample(self.n_samples)\n\n    def setup(self, dist):\n        np.random.seed(42)\n        self.n_samples = 1000\n        self.randvar = get_randvar(distribution_name=dist)", "min_run_count": 2, "name": "distribution.Sampling.time_sample", "number": 0, "param_names": ["dist"], "params": [["'univar_normal'", "'multivar_normal'", "'matrixvar_normal'", "'symmatrixvar_normal'"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "f20f857be1d0c0f4340e8064e5285dad677a08c3d33aa21133d190a573c4fad8", "warmup_time": -1}, "linearsolvers.LinSolve.mem_solve": {"code": "class LinSolve:\n    def mem_solve(self, system):\n        # Solve linear system\n        self.xhat, self.Ahat, self.Ainvhat, _ = problinsolve(A=self.A, b=self.b)\n\n    def setup(self, system):\n        # Seed\n        np.random.seed(42)\n    \n        if system == \"sparse\":\n            self.A, self.b = load_poisson_linear_system()\n        elif system == \"dense\":\n            self.A = np.array([\n                [2.3, -2.3, 3.5, 4.2, 1.8],\n                [-2.3, 3.0, -3.5, -4.8, -1.9],\n                [3.5, -3.5, 6.9, 5.8, 0.8],\n                [4.2, -4.8, 5.8, 10.1, 6.3],\n                [1.8, -1.9, 0.8, 6.3, 12.1]\n            ])\n            self.b = np.random.normal(size=self.A.shape[0])\n        elif system == \"large-scale\":\n            self.A = None\n            self.b = None", "name": "linearsolvers.LinSolve.mem_solve", "param_names": ["system"], "params": [["'sparse'", "'dense'"]], "timeout": 60.0, "type": "memory", "unit": "bytes", "version": "5f89a23f7f1a2da54cdfdb1304351cff79c2ff2ccbca48a1bc002ab792272dd5"}, "linearsolvers.LinSolve.peakmem_solve": {"code": "class LinSolve:\n    def peakmem_solve(self, system):\n        # Solve linear system\n        self.xhat, self.Ahat, self.Ainvhat, _ = problinsolve(A=self.A, b=self.b)\n\n    def setup(self, system):\n        # Seed\n        np.random.seed(42)\n    \n        if system == \"sparse\":\n            self.A, self.b = load_poisson_linear_system()\n        elif system == \"dense\":\n            self.A = np.array([\n                [2.3, -2.3, 3.5, 4.2, 1.8],\n                [-2.3, 3.0, -3.5, -4.8, -1.9],\n                [3.5, -3.5, 6.9, 5.8, 0.8],\n                [4.2, -4.8, 5.8, 10.1, 6.3],\n                [1.8, -1.9, 0.8, 6.3, 12.1]\n            ])\n            self.b = np.random.normal(size=self.A.shape[0])\n        elif system == \"large-scale\":\n            self.A = None\n            self.b = None", "name": "linearsolvers.LinSolve.peakmem_solve", "param_names": ["system"], "params": [["'sparse'", "'dense'"]], "timeout": 60.0, "type": "peakmemory", "unit": "bytes", "version": "af6eef7ddd7caef365704cfdf46a91503b5d9fb963dac8126745b6ba718b4349"}, "linearsolvers.LinSolve.time_solve": {"code": "class LinSolve:\n    def time_solve(self, system):\n        # Solve linear system\n        self.xhat, self.Ahat, self.Ainvhat, _ = problinsolve(A=self.A, b=self.b)\n\n    def setup(self, system):\n        # Seed\n        np.random.seed(42)\n    \n        if system == \"sparse\":\n            self.A, self.b = load_poisson_linear_system()\n        elif system == \"dense\":\n            self.A = np.array([\n                [2.3, -2.3, 3.5, 4.2, 1.8],\n                [-2.3, 3.0, -3.5, -4.8, -1.9],\n                [3.5, -3.5, 6.9, 5.8, 0.8],\n                [4.2, -4.8, 5.8, 10.1, 6.3],\n                [1.8, -1.9, 0.8, 6.3, 12.1]\n            ])\n            self.b = np.random.normal(size=self.A.shape[0])\n        elif system == \"large-scale\":\n            self.A = None\n            self.b = None", "min_run_count": 2, "name": "linearsolvers.LinSolve.time_solve", "number": 0, "param_names": ["system"], "params": [["'sparse'", "'dense'"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "bc59b7a996dbae83510dbeb7fe6d300304bedfd9fce6b8420b24f84416328c01", "warmup_time": -1}, "linearsolvers.PosteriorDist.time_sample": {"code": "class PosteriorDist:\n    def time_sample(self, output):\n        if output == \"solution\":\n            self.xhat.sample(self.n_samples)\n        elif output == \"matrix\":\n            self.Ahat.sample(self.n_samples)\n        elif output == \"matrix_inverse\":\n            self.Ainvhat.sample(self.n_samples)\n\n    def setup(self, output):\n        # Sparse system\n        self.A, self.b = load_poisson_linear_system()\n    \n        # Solve linear system\n        self.xhat, self.Ahat, self.Ainvhat, _ = problinsolve(A=self.A, b=self.b)\n    \n        # Benchmark parameters\n        self.n_samples = 10", "min_run_count": 2, "name": "linearsolvers.PosteriorDist.time_sample", "number": 0, "param_names": ["output"], "params": [["'solution'", "'matrix'", "'matrix_inverse'"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "e140297042a5ac6c236f00da17a4cb3660a63433fcab0c2f619ef7a57ddfb3d8", "warmup_time": -1}}, "machines": {"cloudrunner": {"machine": "cloudrunner", "version": 1}}, "tags": {"v.0.0.1-alpha": 326, "v0.0.1-beta": 514}, "pages": [["", "Grid view", "Display as a agrid"], ["summarylist", "List view", "Display as a list"], ["regressions", "Show regressions", "Display information about recent regressions"]]}