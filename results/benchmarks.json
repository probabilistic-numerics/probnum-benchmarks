{
    "filtsmooth.DenseGridOperations.peakmem_dense_filter": {
        "code": "class DenseGridOperations:\n    def peakmem_dense_filter(self, linearization_implementation, num_samples):\n        self.filtering_posterior(self.dense_locations)\n\n    def setup(self, linearization_implementation, num_samples):\n        dynmod, measmod, initrv, info = load_pendulum()\n        linearization, implementation = linearization_implementation\n        _lin_method = {\n            \"ekf\": functools.partial(\n                filtsmooth.DiscreteEKFComponent,\n                forward_implementation=implementation,\n                backward_implementation=implementation,\n            ),\n            \"ukf\": filtsmooth.DiscreteUKFComponent,\n        }[linearization]\n    \n        self.locations = np.arange(0.0, info[\"tmax\"], step=info[\"dt\"])\n        self.dense_locations = np.sort(\n            np.unique(\n                np.random.uniform(\n                    low=0.0,\n                    high=1.2 * info[\"tmax\"],\n                    size=int(1.2 * len(self.locations)),\n                )\n            )\n        )\n    \n        _, self.observations = statespace.generate_samples(\n            dynmod=dynmod, measmod=measmod, initrv=initrv, times=self.locations\n        )\n        self.regression_problem = problems.RegressionProblem(\n            observations=self.observations, locations=self.locations\n        )\n    \n        linearized_dynmod = _lin_method(dynmod)\n        linearized_measmod = _lin_method(measmod)\n    \n        self.kalman_filter = filtsmooth.Kalman(\n            dynamics_model=linearized_dynmod,\n            measurement_model=linearized_measmod,\n            initrv=initrv,\n        )\n        self.filtering_posterior = self.kalman_filter.filter(self.regression_problem)\n        self.smoothing_posterior = self.kalman_filter.smooth(\n            filter_posterior=self.filtering_posterior\n        )",
        "name": "filtsmooth.DenseGridOperations.peakmem_dense_filter",
        "param_names": [
            "linearization_implementation",
            "num_samples"
        ],
        "params": [
            [
                "('ekf', 'classic')",
                "('ekf', 'sqrt')",
                "('ukf', 'classic')"
            ],
            [
                "1",
                "10"
            ]
        ],
        "timeout": 60.0,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "c0eccd7d0a84bdb9b1811f3b61122d3f55e2476d14cdb3daf0ebaa4520ee982b"
    },
    "filtsmooth.DenseGridOperations.peakmem_dense_smoother": {
        "code": "class DenseGridOperations:\n    def peakmem_dense_smoother(self, linearization_implementation, num_samples):\n        self.smoothing_posterior(self.dense_locations)\n\n    def setup(self, linearization_implementation, num_samples):\n        dynmod, measmod, initrv, info = load_pendulum()\n        linearization, implementation = linearization_implementation\n        _lin_method = {\n            \"ekf\": functools.partial(\n                filtsmooth.DiscreteEKFComponent,\n                forward_implementation=implementation,\n                backward_implementation=implementation,\n            ),\n            \"ukf\": filtsmooth.DiscreteUKFComponent,\n        }[linearization]\n    \n        self.locations = np.arange(0.0, info[\"tmax\"], step=info[\"dt\"])\n        self.dense_locations = np.sort(\n            np.unique(\n                np.random.uniform(\n                    low=0.0,\n                    high=1.2 * info[\"tmax\"],\n                    size=int(1.2 * len(self.locations)),\n                )\n            )\n        )\n    \n        _, self.observations = statespace.generate_samples(\n            dynmod=dynmod, measmod=measmod, initrv=initrv, times=self.locations\n        )\n        self.regression_problem = problems.RegressionProblem(\n            observations=self.observations, locations=self.locations\n        )\n    \n        linearized_dynmod = _lin_method(dynmod)\n        linearized_measmod = _lin_method(measmod)\n    \n        self.kalman_filter = filtsmooth.Kalman(\n            dynamics_model=linearized_dynmod,\n            measurement_model=linearized_measmod,\n            initrv=initrv,\n        )\n        self.filtering_posterior = self.kalman_filter.filter(self.regression_problem)\n        self.smoothing_posterior = self.kalman_filter.smooth(\n            filter_posterior=self.filtering_posterior\n        )",
        "name": "filtsmooth.DenseGridOperations.peakmem_dense_smoother",
        "param_names": [
            "linearization_implementation",
            "num_samples"
        ],
        "params": [
            [
                "('ekf', 'classic')",
                "('ekf', 'sqrt')",
                "('ukf', 'classic')"
            ],
            [
                "1",
                "10"
            ]
        ],
        "timeout": 60.0,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "4e10ee6a0d892df4642d5f7a863a18c329735251af012e5473b98255ee8db756"
    },
    "filtsmooth.DenseGridOperations.peakmem_sample": {
        "code": "class DenseGridOperations:\n    def peakmem_sample(self, linearization_implementation, num_samples):\n        self.smoothing_posterior.sample(t=self.dense_locations, size=num_samples)\n\n    def setup(self, linearization_implementation, num_samples):\n        dynmod, measmod, initrv, info = load_pendulum()\n        linearization, implementation = linearization_implementation\n        _lin_method = {\n            \"ekf\": functools.partial(\n                filtsmooth.DiscreteEKFComponent,\n                forward_implementation=implementation,\n                backward_implementation=implementation,\n            ),\n            \"ukf\": filtsmooth.DiscreteUKFComponent,\n        }[linearization]\n    \n        self.locations = np.arange(0.0, info[\"tmax\"], step=info[\"dt\"])\n        self.dense_locations = np.sort(\n            np.unique(\n                np.random.uniform(\n                    low=0.0,\n                    high=1.2 * info[\"tmax\"],\n                    size=int(1.2 * len(self.locations)),\n                )\n            )\n        )\n    \n        _, self.observations = statespace.generate_samples(\n            dynmod=dynmod, measmod=measmod, initrv=initrv, times=self.locations\n        )\n        self.regression_problem = problems.RegressionProblem(\n            observations=self.observations, locations=self.locations\n        )\n    \n        linearized_dynmod = _lin_method(dynmod)\n        linearized_measmod = _lin_method(measmod)\n    \n        self.kalman_filter = filtsmooth.Kalman(\n            dynamics_model=linearized_dynmod,\n            measurement_model=linearized_measmod,\n            initrv=initrv,\n        )\n        self.filtering_posterior = self.kalman_filter.filter(self.regression_problem)\n        self.smoothing_posterior = self.kalman_filter.smooth(\n            filter_posterior=self.filtering_posterior\n        )",
        "name": "filtsmooth.DenseGridOperations.peakmem_sample",
        "param_names": [
            "linearization_implementation",
            "num_samples"
        ],
        "params": [
            [
                "('ekf', 'classic')",
                "('ekf', 'sqrt')",
                "('ukf', 'classic')"
            ],
            [
                "1",
                "10"
            ]
        ],
        "timeout": 60.0,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "bca65b02bbb1a8069264aa2ceeb8a381401775766cd7d56288f1612ab2acaeed"
    },
    "filtsmooth.DenseGridOperations.time_dense_filter": {
        "code": "class DenseGridOperations:\n    def time_dense_filter(self, linearization_implementation, num_samples):\n        self.filtering_posterior(self.dense_locations)\n\n    def setup(self, linearization_implementation, num_samples):\n        dynmod, measmod, initrv, info = load_pendulum()\n        linearization, implementation = linearization_implementation\n        _lin_method = {\n            \"ekf\": functools.partial(\n                filtsmooth.DiscreteEKFComponent,\n                forward_implementation=implementation,\n                backward_implementation=implementation,\n            ),\n            \"ukf\": filtsmooth.DiscreteUKFComponent,\n        }[linearization]\n    \n        self.locations = np.arange(0.0, info[\"tmax\"], step=info[\"dt\"])\n        self.dense_locations = np.sort(\n            np.unique(\n                np.random.uniform(\n                    low=0.0,\n                    high=1.2 * info[\"tmax\"],\n                    size=int(1.2 * len(self.locations)),\n                )\n            )\n        )\n    \n        _, self.observations = statespace.generate_samples(\n            dynmod=dynmod, measmod=measmod, initrv=initrv, times=self.locations\n        )\n        self.regression_problem = problems.RegressionProblem(\n            observations=self.observations, locations=self.locations\n        )\n    \n        linearized_dynmod = _lin_method(dynmod)\n        linearized_measmod = _lin_method(measmod)\n    \n        self.kalman_filter = filtsmooth.Kalman(\n            dynamics_model=linearized_dynmod,\n            measurement_model=linearized_measmod,\n            initrv=initrv,\n        )\n        self.filtering_posterior = self.kalman_filter.filter(self.regression_problem)\n        self.smoothing_posterior = self.kalman_filter.smooth(\n            filter_posterior=self.filtering_posterior\n        )",
        "min_run_count": 2,
        "name": "filtsmooth.DenseGridOperations.time_dense_filter",
        "number": 0,
        "param_names": [
            "linearization_implementation",
            "num_samples"
        ],
        "params": [
            [
                "('ekf', 'classic')",
                "('ekf', 'sqrt')",
                "('ukf', 'classic')"
            ],
            [
                "1",
                "10"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "e79d6fbd128474bc1ec2de2fcd96a2a84c647789b6b545a27e06edc13860ff33",
        "warmup_time": -1
    },
    "filtsmooth.DenseGridOperations.time_dense_smoother": {
        "code": "class DenseGridOperations:\n    def time_dense_smoother(self, linearization_implementation, num_samples):\n        self.smoothing_posterior(self.dense_locations)\n\n    def setup(self, linearization_implementation, num_samples):\n        dynmod, measmod, initrv, info = load_pendulum()\n        linearization, implementation = linearization_implementation\n        _lin_method = {\n            \"ekf\": functools.partial(\n                filtsmooth.DiscreteEKFComponent,\n                forward_implementation=implementation,\n                backward_implementation=implementation,\n            ),\n            \"ukf\": filtsmooth.DiscreteUKFComponent,\n        }[linearization]\n    \n        self.locations = np.arange(0.0, info[\"tmax\"], step=info[\"dt\"])\n        self.dense_locations = np.sort(\n            np.unique(\n                np.random.uniform(\n                    low=0.0,\n                    high=1.2 * info[\"tmax\"],\n                    size=int(1.2 * len(self.locations)),\n                )\n            )\n        )\n    \n        _, self.observations = statespace.generate_samples(\n            dynmod=dynmod, measmod=measmod, initrv=initrv, times=self.locations\n        )\n        self.regression_problem = problems.RegressionProblem(\n            observations=self.observations, locations=self.locations\n        )\n    \n        linearized_dynmod = _lin_method(dynmod)\n        linearized_measmod = _lin_method(measmod)\n    \n        self.kalman_filter = filtsmooth.Kalman(\n            dynamics_model=linearized_dynmod,\n            measurement_model=linearized_measmod,\n            initrv=initrv,\n        )\n        self.filtering_posterior = self.kalman_filter.filter(self.regression_problem)\n        self.smoothing_posterior = self.kalman_filter.smooth(\n            filter_posterior=self.filtering_posterior\n        )",
        "min_run_count": 2,
        "name": "filtsmooth.DenseGridOperations.time_dense_smoother",
        "number": 0,
        "param_names": [
            "linearization_implementation",
            "num_samples"
        ],
        "params": [
            [
                "('ekf', 'classic')",
                "('ekf', 'sqrt')",
                "('ukf', 'classic')"
            ],
            [
                "1",
                "10"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "c87631656f2bc60fb23ae7ad19a427642123dd53f3be7e43db31fcd93eddafab",
        "warmup_time": -1
    },
    "filtsmooth.DenseGridOperations.time_sample": {
        "code": "class DenseGridOperations:\n    def time_sample(self, linearization_implementation, num_samples):\n        self.smoothing_posterior.sample(t=self.dense_locations, size=num_samples)\n\n    def setup(self, linearization_implementation, num_samples):\n        dynmod, measmod, initrv, info = load_pendulum()\n        linearization, implementation = linearization_implementation\n        _lin_method = {\n            \"ekf\": functools.partial(\n                filtsmooth.DiscreteEKFComponent,\n                forward_implementation=implementation,\n                backward_implementation=implementation,\n            ),\n            \"ukf\": filtsmooth.DiscreteUKFComponent,\n        }[linearization]\n    \n        self.locations = np.arange(0.0, info[\"tmax\"], step=info[\"dt\"])\n        self.dense_locations = np.sort(\n            np.unique(\n                np.random.uniform(\n                    low=0.0,\n                    high=1.2 * info[\"tmax\"],\n                    size=int(1.2 * len(self.locations)),\n                )\n            )\n        )\n    \n        _, self.observations = statespace.generate_samples(\n            dynmod=dynmod, measmod=measmod, initrv=initrv, times=self.locations\n        )\n        self.regression_problem = problems.RegressionProblem(\n            observations=self.observations, locations=self.locations\n        )\n    \n        linearized_dynmod = _lin_method(dynmod)\n        linearized_measmod = _lin_method(measmod)\n    \n        self.kalman_filter = filtsmooth.Kalman(\n            dynamics_model=linearized_dynmod,\n            measurement_model=linearized_measmod,\n            initrv=initrv,\n        )\n        self.filtering_posterior = self.kalman_filter.filter(self.regression_problem)\n        self.smoothing_posterior = self.kalman_filter.smooth(\n            filter_posterior=self.filtering_posterior\n        )",
        "min_run_count": 2,
        "name": "filtsmooth.DenseGridOperations.time_sample",
        "number": 0,
        "param_names": [
            "linearization_implementation",
            "num_samples"
        ],
        "params": [
            [
                "('ekf', 'classic')",
                "('ekf', 'sqrt')",
                "('ukf', 'classic')"
            ],
            [
                "1",
                "10"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "8f22c2856d7aa913248924d2fd9a477858c80bc2c73c6618b5c677d177deb61b",
        "warmup_time": -1
    },
    "filtsmooth.Filtering.peakmem_filter": {
        "code": "class Filtering:\n    def peakmem_filter(self, linearization_implementation):\n        self.kalman_filter.filter(self.regression_problem)\n\n    def setup(self, linearization_implementation):\n        dynmod, measmod, initrv, info = load_pendulum()\n        linearization, implementation = linearization_implementation\n        _lin_method = {\n            \"ekf\": functools.partial(\n                filtsmooth.DiscreteEKFComponent,\n                forward_implementation=implementation,\n                backward_implementation=implementation,\n            ),\n            \"ukf\": filtsmooth.DiscreteUKFComponent,\n        }[linearization]\n    \n        self.locations = np.arange(0.0, info[\"tmax\"], step=info[\"dt\"])\n        _, self.observations = statespace.generate_samples(\n            dynmod=dynmod, measmod=measmod, initrv=initrv, times=self.locations\n        )\n        self.regression_problem = problems.RegressionProblem(\n            observations=self.observations, locations=self.locations\n        )\n    \n        linearized_dynmod = _lin_method(dynmod)\n        linearized_measmod = _lin_method(measmod)\n    \n        self.kalman_filter = filtsmooth.Kalman(\n            dynamics_model=linearized_dynmod,\n            measurement_model=linearized_measmod,\n            initrv=initrv,\n        )",
        "name": "filtsmooth.Filtering.peakmem_filter",
        "param_names": [
            "linearization_implementation"
        ],
        "params": [
            [
                "('ekf', 'classic')",
                "('ekf', 'sqrt')",
                "('ukf', 'classic')"
            ]
        ],
        "timeout": 60.0,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "d5b85676d5ad4ed46324219a776d7f69f41d47745eb4d0f1476688722c9e03db"
    },
    "filtsmooth.Filtering.time_filter": {
        "code": "class Filtering:\n    def time_filter(self, linearization_implementation):\n        self.kalman_filter.filter(self.regression_problem)\n\n    def setup(self, linearization_implementation):\n        dynmod, measmod, initrv, info = load_pendulum()\n        linearization, implementation = linearization_implementation\n        _lin_method = {\n            \"ekf\": functools.partial(\n                filtsmooth.DiscreteEKFComponent,\n                forward_implementation=implementation,\n                backward_implementation=implementation,\n            ),\n            \"ukf\": filtsmooth.DiscreteUKFComponent,\n        }[linearization]\n    \n        self.locations = np.arange(0.0, info[\"tmax\"], step=info[\"dt\"])\n        _, self.observations = statespace.generate_samples(\n            dynmod=dynmod, measmod=measmod, initrv=initrv, times=self.locations\n        )\n        self.regression_problem = problems.RegressionProblem(\n            observations=self.observations, locations=self.locations\n        )\n    \n        linearized_dynmod = _lin_method(dynmod)\n        linearized_measmod = _lin_method(measmod)\n    \n        self.kalman_filter = filtsmooth.Kalman(\n            dynamics_model=linearized_dynmod,\n            measurement_model=linearized_measmod,\n            initrv=initrv,\n        )",
        "min_run_count": 2,
        "name": "filtsmooth.Filtering.time_filter",
        "number": 0,
        "param_names": [
            "linearization_implementation"
        ],
        "params": [
            [
                "('ekf', 'classic')",
                "('ekf', 'sqrt')",
                "('ukf', 'classic')"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "00a8b95ae232a449d0eaad495c87630e6d320f86ab649b708510c3fc2458b81e",
        "warmup_time": -1
    },
    "filtsmooth.Smoothing.peakmem_smooth": {
        "code": "class Smoothing:\n    def peakmem_smooth(self, linearization_implementation):\n        self.kalman_filter.smooth(filter_posterior=self.filtering_posterior)\n\n    def setup(self, linearization_implementation):\n        dynmod, measmod, initrv, info = load_pendulum()\n        linearization, implementation = linearization_implementation\n        _lin_method = {\n            \"ekf\": functools.partial(\n                filtsmooth.DiscreteEKFComponent,\n                forward_implementation=implementation,\n                backward_implementation=implementation,\n            ),\n            \"ukf\": filtsmooth.DiscreteUKFComponent,\n        }[linearization]\n    \n        self.locations = np.arange(0.0, info[\"tmax\"], step=info[\"dt\"])\n        _, self.observations = statespace.generate_samples(\n            dynmod=dynmod, measmod=measmod, initrv=initrv, times=self.locations\n        )\n        self.regression_problem = problems.RegressionProblem(\n            observations=self.observations, locations=self.locations\n        )\n    \n        linearized_dynmod = _lin_method(dynmod)\n        linearized_measmod = _lin_method(measmod)\n    \n        self.kalman_filter = filtsmooth.Kalman(\n            dynamics_model=linearized_dynmod,\n            measurement_model=linearized_measmod,\n            initrv=initrv,\n        )\n        self.filtering_posterior = self.kalman_filter.filter(self.regression_problem)",
        "name": "filtsmooth.Smoothing.peakmem_smooth",
        "param_names": [
            "linearization_implementation"
        ],
        "params": [
            [
                "('ekf', 'classic')",
                "('ekf', 'sqrt')",
                "('ukf', 'classic')"
            ]
        ],
        "timeout": 60.0,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "b673daf4dc18bd77496a2787ba02cd6d6cd9faf7abe02fa8144d1c8d5480cb9d"
    },
    "filtsmooth.Smoothing.time_smooth": {
        "code": "class Smoothing:\n    def time_smooth(self, linearization_implementation):\n        self.kalman_filter.smooth(filter_posterior=self.filtering_posterior)\n\n    def setup(self, linearization_implementation):\n        dynmod, measmod, initrv, info = load_pendulum()\n        linearization, implementation = linearization_implementation\n        _lin_method = {\n            \"ekf\": functools.partial(\n                filtsmooth.DiscreteEKFComponent,\n                forward_implementation=implementation,\n                backward_implementation=implementation,\n            ),\n            \"ukf\": filtsmooth.DiscreteUKFComponent,\n        }[linearization]\n    \n        self.locations = np.arange(0.0, info[\"tmax\"], step=info[\"dt\"])\n        _, self.observations = statespace.generate_samples(\n            dynmod=dynmod, measmod=measmod, initrv=initrv, times=self.locations\n        )\n        self.regression_problem = problems.RegressionProblem(\n            observations=self.observations, locations=self.locations\n        )\n    \n        linearized_dynmod = _lin_method(dynmod)\n        linearized_measmod = _lin_method(measmod)\n    \n        self.kalman_filter = filtsmooth.Kalman(\n            dynamics_model=linearized_dynmod,\n            measurement_model=linearized_measmod,\n            initrv=initrv,\n        )\n        self.filtering_posterior = self.kalman_filter.filter(self.regression_problem)",
        "min_run_count": 2,
        "name": "filtsmooth.Smoothing.time_smooth",
        "number": 0,
        "param_names": [
            "linearization_implementation"
        ],
        "params": [
            [
                "('ekf', 'classic')",
                "('ekf', 'sqrt')",
                "('ukf', 'classic')"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "354eb0f9e6db47b59ccddda91a1e20c46d10e9e00d30de4790c3ceffbae05729",
        "warmup_time": -1
    },
    "ivpsolvers.IVPSolve.peakmem_solve": {
        "code": "class IVPSolve:\n    def peakmem_solve(self, method, algo_order):\n        f = self.ivp.rhs\n        df = self.ivp.jacobian\n        t0, tmax = self.ivp.timespan\n        y0 = self.ivp.initrv.mean\n        probsolve_ivp(\n            f,\n            t0,\n            tmax,\n            y0,\n            df=df,\n            method=method,\n            dense_output=True,\n            algo_order=algo_order,\n            step=self.stepsize,\n            adaptive=False,\n        )\n\n    def setup(self, method, prior):\n        # pylint: disable=invalid-name\n        self.ivp = load_lotkavolterra()\n        self.stepsize = 1e-1",
        "name": "ivpsolvers.IVPSolve.peakmem_solve",
        "param_names": [
            "method",
            "algo_order"
        ],
        "params": [
            [
                "'ek0'",
                "'ek1'"
            ],
            [
                "2",
                "3"
            ]
        ],
        "timeout": 60.0,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "4355f33a1226e75a219f8222b8472582c26e9fdc3d9d2488e7343b952fa3000e"
    },
    "ivpsolvers.IVPSolve.time_solve": {
        "code": "class IVPSolve:\n    def time_solve(self, method, algo_order):\n        f = self.ivp.rhs\n        df = self.ivp.jacobian\n        t0, tmax = self.ivp.timespan\n        y0 = self.ivp.initrv.mean\n        probsolve_ivp(\n            f,\n            t0,\n            tmax,\n            y0,\n            df=df,\n            method=method,\n            dense_output=True,\n            algo_order=algo_order,\n            step=self.stepsize,\n            adaptive=False,\n        )\n\n    def setup(self, method, prior):\n        # pylint: disable=invalid-name\n        self.ivp = load_lotkavolterra()\n        self.stepsize = 1e-1",
        "min_run_count": 2,
        "name": "ivpsolvers.IVPSolve.time_solve",
        "number": 0,
        "param_names": [
            "method",
            "algo_order"
        ],
        "params": [
            [
                "'ek0'",
                "'ek1'"
            ],
            [
                "2",
                "3"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "6a79b92752b388b6b1c46d5394b9d6f4baf0e5455b6d5de65510fdb0e923bf9d",
        "warmup_time": -1
    },
    "kernels.Kernels.peakmem_kernel_matrix": {
        "code": "class Kernels:\n    def peakmem_kernel_matrix(self, kernel, n_datapoints):\n        \"\"\"Peak memory of sampling process.\"\"\"\n        self.kernel(self.data)\n\n    def setup(self, kernel, n_datapoints):\n        rng = np.random.default_rng(42)\n        self.input_dim = 100\n        self.data = rng.normal(size=(n_datapoints, self.input_dim))\n        self.kernel = get_kernel(kernel_name=kernel, input_dim=self.input_dim)",
        "name": "kernels.Kernels.peakmem_kernel_matrix",
        "param_names": [
            "kernel",
            "n_datapoints"
        ],
        "params": [
            [
                "'white_noise'",
                "'linear'",
                "'polynomial'",
                "'exp_quad'",
                "'rat_quad'",
                "'matern12'",
                "'matern32'",
                "'matern52'",
                "'matern72'"
            ],
            [
                "10",
                "100",
                "1000"
            ]
        ],
        "timeout": 60.0,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "b4f420e1ef1214a865c6f026feb39a43143f57a26b361623fb63418e2f0a01b1"
    },
    "kernels.Kernels.time_kernel_matrix": {
        "code": "class Kernels:\n    def time_kernel_matrix(self, kernel, n_datapoints):\n        \"\"\"Times sampling from this distribution.\"\"\"\n        self.kernel(self.data)\n\n    def setup(self, kernel, n_datapoints):\n        rng = np.random.default_rng(42)\n        self.input_dim = 100\n        self.data = rng.normal(size=(n_datapoints, self.input_dim))\n        self.kernel = get_kernel(kernel_name=kernel, input_dim=self.input_dim)",
        "min_run_count": 2,
        "name": "kernels.Kernels.time_kernel_matrix",
        "number": 0,
        "param_names": [
            "kernel",
            "n_datapoints"
        ],
        "params": [
            [
                "'white_noise'",
                "'linear'",
                "'polynomial'",
                "'exp_quad'",
                "'rat_quad'",
                "'matern12'",
                "'matern32'",
                "'matern52'",
                "'matern72'"
            ],
            [
                "10",
                "100",
                "1000"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "bd80bb62c96bc059c77c591c8a2f9c501cce5fe29dd92efb750ce55f0ada226e",
        "warmup_time": -1
    },
    "linearsolvers.LinSolve.mem_solve": {
        "code": "class LinSolve:\n    def mem_solve(self, system):\n        \"\"\"Time solving a linear system.\"\"\"\n        problinsolve(A=self.A, b=self.b)\n\n    def setup(self, system):\n        # Seed\n        np.random.seed(42)\n    \n        if system == \"sparse\":\n            (\n                self.A,\n                self.b,\n            ) = load_poisson_linear_system()\n        elif system == \"dense\":\n            self.A = SPD_MATRIX_5x5\n            self.b = np.random.normal(size=self.A.shape[0])\n        elif system == \"large-scale\":\n            self.A = None\n            self.b = None",
        "name": "linearsolvers.LinSolve.mem_solve",
        "param_names": [
            "system"
        ],
        "params": [
            [
                "'sparse'",
                "'dense'"
            ]
        ],
        "timeout": 60.0,
        "type": "memory",
        "unit": "bytes",
        "version": "339b33f3828c63a96101d46a5fc0516e96c6493bd4c7299a1d1de5ae414517ff"
    },
    "linearsolvers.LinSolve.peakmem_solve": {
        "code": "class LinSolve:\n    def peakmem_solve(self, system):\n        \"\"\"Time solving a linear system.\"\"\"\n        problinsolve(A=self.A, b=self.b)\n\n    def setup(self, system):\n        # Seed\n        np.random.seed(42)\n    \n        if system == \"sparse\":\n            (\n                self.A,\n                self.b,\n            ) = load_poisson_linear_system()\n        elif system == \"dense\":\n            self.A = SPD_MATRIX_5x5\n            self.b = np.random.normal(size=self.A.shape[0])\n        elif system == \"large-scale\":\n            self.A = None\n            self.b = None",
        "name": "linearsolvers.LinSolve.peakmem_solve",
        "param_names": [
            "system"
        ],
        "params": [
            [
                "'sparse'",
                "'dense'"
            ]
        ],
        "timeout": 60.0,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "6647c7e69e7c7de96befd7f8e9df8d0cbef4865c223a4c915786b12c84cb92c2"
    },
    "linearsolvers.LinSolve.time_solve": {
        "code": "class LinSolve:\n    def time_solve(self, system):\n        \"\"\"Time solving a linear system.\"\"\"\n        problinsolve(A=self.A, b=self.b)\n\n    def setup(self, system):\n        # Seed\n        np.random.seed(42)\n    \n        if system == \"sparse\":\n            (\n                self.A,\n                self.b,\n            ) = load_poisson_linear_system()\n        elif system == \"dense\":\n            self.A = SPD_MATRIX_5x5\n            self.b = np.random.normal(size=self.A.shape[0])\n        elif system == \"large-scale\":\n            self.A = None\n            self.b = None",
        "min_run_count": 2,
        "name": "linearsolvers.LinSolve.time_solve",
        "number": 0,
        "param_names": [
            "system"
        ],
        "params": [
            [
                "'sparse'",
                "'dense'"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "00e14040e21d8eb565e633cf998a4aa266616e92f9a884480a4cb8dd4050545a",
        "warmup_time": -1
    },
    "linearsolvers.PosteriorDist.time_sample": {
        "code": "class PosteriorDist:\n    def time_sample(self, output):\n        \"\"\"Time sampling from the posterior distribution.\"\"\"\n        if output == \"solution\":\n            self.xhat.sample(self.n_samples)\n        elif output == \"matrix\":\n            self.Ahat.sample(self.n_samples)\n        elif output == \"matrix_inverse\":\n            self.Ainvhat.sample(self.n_samples)\n\n    def setup(self, output):\n        # pylint: disable=invalid-name\n    \n        # Sparse system\n        self.A, self.b = load_poisson_linear_system()\n    \n        # Solve linear system\n        self.xhat, self.Ahat, self.Ainvhat, _ = problinsolve(A=self.A, b=self.b)\n    \n        # Benchmark parameters\n        self.n_samples = 10",
        "min_run_count": 2,
        "name": "linearsolvers.PosteriorDist.time_sample",
        "number": 0,
        "param_names": [
            "output"
        ],
        "params": [
            [
                "'solution'",
                "'matrix'",
                "'matrix_inverse'"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "da540442fa5cdd201a5b76df0ad91f4ffcd4c63dee83a54c466fe9079ff0ef4d",
        "warmup_time": -1
    },
    "random_variables.Functions.time_distr_functions": {
        "code": "class Functions:\n    def time_distr_functions(self, randvar, method):\n        \"\"\"Times evaluation of the pdf, logpdf, cdf and logcdf.\"\"\"\n        try:\n            if method == \"pdf\":\n                self.randvar.pdf(x=self.eval_point)\n            elif method == \"logpdf\":\n                self.randvar.logpdf(x=self.eval_point)\n            elif method == \"cdf\":\n                self.randvar.cdf(x=self.quantile)\n            elif method == \"logcdf\":\n                self.randvar.logcdf(x=self.quantile)\n        except NotImplementedError:\n            pass\n\n    def setup(self, randvar, method):\n        self.randvar = get_randvar(rv_name=randvar)\n        self.eval_point = np.random.uniform(size=self.randvar.shape)\n        self.quantile = np.random.uniform(size=self.randvar.shape)",
        "min_run_count": 2,
        "name": "random_variables.Functions.time_distr_functions",
        "number": 0,
        "param_names": [
            "randvar",
            "method"
        ],
        "params": [
            [
                "'univar_normal'",
                "'multivar_normal'",
                "'matrixvar_normal'",
                "'symmatrixvar_normal'",
                "'operatorvar_normal'"
            ],
            [
                "'pdf'",
                "'logpdf'",
                "'cdf'",
                "'logcdf'"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "7e411912776b427b31a26b16d9bb33e49fba6bef3e1d49b79641f7b2138e2ff9",
        "warmup_time": -1
    },
    "random_variables.Sampling.peakmem_sample": {
        "code": "class Sampling:\n    def peakmem_sample(self, randvar):\n        \"\"\"Peak memory of sampling process.\"\"\"\n        self.randvar.sample(self.n_samples)\n\n    def setup(self, randvar):\n        np.random.seed(42)\n        self.n_samples = 1000\n        self.randvar = get_randvar(rv_name=randvar)",
        "name": "random_variables.Sampling.peakmem_sample",
        "param_names": [
            "randvar"
        ],
        "params": [
            [
                "'univar_normal'",
                "'multivar_normal'",
                "'matrixvar_normal'",
                "'symmatrixvar_normal'",
                "'operatorvar_normal'"
            ]
        ],
        "timeout": 60.0,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "8c7bfdb1e4a4015a16a3a6d46e1f74176aef0e16995f157e92bdbf632c6326d1"
    },
    "random_variables.Sampling.time_sample": {
        "code": "class Sampling:\n    def time_sample(self, randvar):\n        \"\"\"Times sampling from this distribution.\"\"\"\n        self.randvar.sample(self.n_samples)\n\n    def setup(self, randvar):\n        np.random.seed(42)\n        self.n_samples = 1000\n        self.randvar = get_randvar(rv_name=randvar)",
        "min_run_count": 2,
        "name": "random_variables.Sampling.time_sample",
        "number": 0,
        "param_names": [
            "randvar"
        ],
        "params": [
            [
                "'univar_normal'",
                "'multivar_normal'",
                "'matrixvar_normal'",
                "'symmatrixvar_normal'",
                "'operatorvar_normal'"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "27dbfe7ba451737d64221100d07633db8df65f4992b6dc037ff7e395fbbf4697",
        "warmup_time": -1
    },
    "version": 2
}