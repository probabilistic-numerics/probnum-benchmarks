{
    "filtsmooth.DenseGridOperations.peakmem_dense_filter": {
        "code": "class DenseGridOperations:\n    def peakmem_dense_filter(self, linearization_implementation, num_samples):\n        self.filtering_posterior(self.dense_locations)\n\n    def setup(self, linearization_implementation, num_samples):\n        measvar = 0.1024\n        initrv = randvars.Normal(np.ones(2), measvar * np.eye(2))\n        regression_problem, info = filtsmooth_zoo.pendulum(\n            measurement_variance=measvar,\n            timespan=(0.0, 4.0),\n            step=0.0075,\n            initrv=initrv,\n        )\n        prior_process = info[\"prior_process\"]\n    \n        linearization, implementation = linearization_implementation\n        _lin_method = {\n            \"ekf\": functools.partial(\n                filtsmooth.DiscreteEKFComponent,\n                forward_implementation=implementation,\n                backward_implementation=implementation,\n            ),\n            \"ukf\": filtsmooth.DiscreteUKFComponent,\n        }[linearization]\n    \n        self.dense_locations = np.sort(\n            np.unique(\n                np.random.uniform(\n                    low=regression_problem.locations[0],\n                    high=1.2 * regression_problem.locations[-1],\n                    size=int(1.2 * len(regression_problem.locations)),\n                )\n            )\n        )\n    \n        linearized_dynmod = _lin_method(prior_process.transition)\n        linearized_measmod = _lin_method(regression_problem.measurement_models[0])\n        regression_problem.measurement_models = [linearized_measmod] * len(\n            regression_problem.locations\n        )\n    \n        prior_process = randprocs.MarkovProcess(\n            transition=linearized_dynmod,\n            initrv=prior_process.initrv,\n            initarg=regression_problem.locations[0],\n        )\n    \n        self.kalman_filter = filtsmooth.Kalman(prior_process=prior_process)\n    \n        self.filtering_posterior, _ = self.kalman_filter.filter(regression_problem)\n        self.smoothing_posterior = self.kalman_filter.smooth(\n            filter_posterior=self.filtering_posterior\n        )",
        "name": "filtsmooth.DenseGridOperations.peakmem_dense_filter",
        "param_names": [
            "linearization_implementation",
            "num_samples"
        ],
        "params": [
            [
                "('ekf', 'classic')",
                "('ekf', 'sqrt')",
                "('ukf', 'classic')"
            ],
            [
                "1",
                "10"
            ]
        ],
        "timeout": 60.0,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "c545609d2519b7fcde1812ed38b2a7c150f31eec3521cf96a776c5b2eaadf2df"
    },
    "filtsmooth.DenseGridOperations.peakmem_dense_smoother": {
        "code": "class DenseGridOperations:\n    def peakmem_dense_smoother(self, linearization_implementation, num_samples):\n        self.smoothing_posterior(self.dense_locations)\n\n    def setup(self, linearization_implementation, num_samples):\n        measvar = 0.1024\n        initrv = randvars.Normal(np.ones(2), measvar * np.eye(2))\n        regression_problem, info = filtsmooth_zoo.pendulum(\n            measurement_variance=measvar,\n            timespan=(0.0, 4.0),\n            step=0.0075,\n            initrv=initrv,\n        )\n        prior_process = info[\"prior_process\"]\n    \n        linearization, implementation = linearization_implementation\n        _lin_method = {\n            \"ekf\": functools.partial(\n                filtsmooth.DiscreteEKFComponent,\n                forward_implementation=implementation,\n                backward_implementation=implementation,\n            ),\n            \"ukf\": filtsmooth.DiscreteUKFComponent,\n        }[linearization]\n    \n        self.dense_locations = np.sort(\n            np.unique(\n                np.random.uniform(\n                    low=regression_problem.locations[0],\n                    high=1.2 * regression_problem.locations[-1],\n                    size=int(1.2 * len(regression_problem.locations)),\n                )\n            )\n        )\n    \n        linearized_dynmod = _lin_method(prior_process.transition)\n        linearized_measmod = _lin_method(regression_problem.measurement_models[0])\n        regression_problem.measurement_models = [linearized_measmod] * len(\n            regression_problem.locations\n        )\n    \n        prior_process = randprocs.MarkovProcess(\n            transition=linearized_dynmod,\n            initrv=prior_process.initrv,\n            initarg=regression_problem.locations[0],\n        )\n    \n        self.kalman_filter = filtsmooth.Kalman(prior_process=prior_process)\n    \n        self.filtering_posterior, _ = self.kalman_filter.filter(regression_problem)\n        self.smoothing_posterior = self.kalman_filter.smooth(\n            filter_posterior=self.filtering_posterior\n        )",
        "name": "filtsmooth.DenseGridOperations.peakmem_dense_smoother",
        "param_names": [
            "linearization_implementation",
            "num_samples"
        ],
        "params": [
            [
                "('ekf', 'classic')",
                "('ekf', 'sqrt')",
                "('ukf', 'classic')"
            ],
            [
                "1",
                "10"
            ]
        ],
        "timeout": 60.0,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "180c0c1ef9bc2c2c9b3672ed316c2116bca721f287d15444f0146b80b4752763"
    },
    "filtsmooth.DenseGridOperations.peakmem_sample": {
        "code": "class DenseGridOperations:\n    def peakmem_sample(self, linearization_implementation, num_samples):\n        self.smoothing_posterior.sample(t=self.dense_locations, size=num_samples)\n\n    def setup(self, linearization_implementation, num_samples):\n        measvar = 0.1024\n        initrv = randvars.Normal(np.ones(2), measvar * np.eye(2))\n        regression_problem, info = filtsmooth_zoo.pendulum(\n            measurement_variance=measvar,\n            timespan=(0.0, 4.0),\n            step=0.0075,\n            initrv=initrv,\n        )\n        prior_process = info[\"prior_process\"]\n    \n        linearization, implementation = linearization_implementation\n        _lin_method = {\n            \"ekf\": functools.partial(\n                filtsmooth.DiscreteEKFComponent,\n                forward_implementation=implementation,\n                backward_implementation=implementation,\n            ),\n            \"ukf\": filtsmooth.DiscreteUKFComponent,\n        }[linearization]\n    \n        self.dense_locations = np.sort(\n            np.unique(\n                np.random.uniform(\n                    low=regression_problem.locations[0],\n                    high=1.2 * regression_problem.locations[-1],\n                    size=int(1.2 * len(regression_problem.locations)),\n                )\n            )\n        )\n    \n        linearized_dynmod = _lin_method(prior_process.transition)\n        linearized_measmod = _lin_method(regression_problem.measurement_models[0])\n        regression_problem.measurement_models = [linearized_measmod] * len(\n            regression_problem.locations\n        )\n    \n        prior_process = randprocs.MarkovProcess(\n            transition=linearized_dynmod,\n            initrv=prior_process.initrv,\n            initarg=regression_problem.locations[0],\n        )\n    \n        self.kalman_filter = filtsmooth.Kalman(prior_process=prior_process)\n    \n        self.filtering_posterior, _ = self.kalman_filter.filter(regression_problem)\n        self.smoothing_posterior = self.kalman_filter.smooth(\n            filter_posterior=self.filtering_posterior\n        )",
        "name": "filtsmooth.DenseGridOperations.peakmem_sample",
        "param_names": [
            "linearization_implementation",
            "num_samples"
        ],
        "params": [
            [
                "('ekf', 'classic')",
                "('ekf', 'sqrt')",
                "('ukf', 'classic')"
            ],
            [
                "1",
                "10"
            ]
        ],
        "timeout": 60.0,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "0e3a8a882aa17695b2bfac1e5dded832c20272a46c82687fd5f6ceaf355de467"
    },
    "filtsmooth.DenseGridOperations.time_dense_filter": {
        "code": "class DenseGridOperations:\n    def time_dense_filter(self, linearization_implementation, num_samples):\n        self.filtering_posterior(self.dense_locations)\n\n    def setup(self, linearization_implementation, num_samples):\n        measvar = 0.1024\n        initrv = randvars.Normal(np.ones(2), measvar * np.eye(2))\n        regression_problem, info = filtsmooth_zoo.pendulum(\n            measurement_variance=measvar,\n            timespan=(0.0, 4.0),\n            step=0.0075,\n            initrv=initrv,\n        )\n        prior_process = info[\"prior_process\"]\n    \n        linearization, implementation = linearization_implementation\n        _lin_method = {\n            \"ekf\": functools.partial(\n                filtsmooth.DiscreteEKFComponent,\n                forward_implementation=implementation,\n                backward_implementation=implementation,\n            ),\n            \"ukf\": filtsmooth.DiscreteUKFComponent,\n        }[linearization]\n    \n        self.dense_locations = np.sort(\n            np.unique(\n                np.random.uniform(\n                    low=regression_problem.locations[0],\n                    high=1.2 * regression_problem.locations[-1],\n                    size=int(1.2 * len(regression_problem.locations)),\n                )\n            )\n        )\n    \n        linearized_dynmod = _lin_method(prior_process.transition)\n        linearized_measmod = _lin_method(regression_problem.measurement_models[0])\n        regression_problem.measurement_models = [linearized_measmod] * len(\n            regression_problem.locations\n        )\n    \n        prior_process = randprocs.MarkovProcess(\n            transition=linearized_dynmod,\n            initrv=prior_process.initrv,\n            initarg=regression_problem.locations[0],\n        )\n    \n        self.kalman_filter = filtsmooth.Kalman(prior_process=prior_process)\n    \n        self.filtering_posterior, _ = self.kalman_filter.filter(regression_problem)\n        self.smoothing_posterior = self.kalman_filter.smooth(\n            filter_posterior=self.filtering_posterior\n        )",
        "min_run_count": 2,
        "name": "filtsmooth.DenseGridOperations.time_dense_filter",
        "number": 0,
        "param_names": [
            "linearization_implementation",
            "num_samples"
        ],
        "params": [
            [
                "('ekf', 'classic')",
                "('ekf', 'sqrt')",
                "('ukf', 'classic')"
            ],
            [
                "1",
                "10"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "fa373ecc9f29921bde672bfd7701382de6dbbed73a7f28d75d1023b7e6db6722",
        "warmup_time": -1
    },
    "filtsmooth.DenseGridOperations.time_dense_smoother": {
        "code": "class DenseGridOperations:\n    def time_dense_smoother(self, linearization_implementation, num_samples):\n        self.smoothing_posterior(self.dense_locations)\n\n    def setup(self, linearization_implementation, num_samples):\n        measvar = 0.1024\n        initrv = randvars.Normal(np.ones(2), measvar * np.eye(2))\n        regression_problem, info = filtsmooth_zoo.pendulum(\n            measurement_variance=measvar,\n            timespan=(0.0, 4.0),\n            step=0.0075,\n            initrv=initrv,\n        )\n        prior_process = info[\"prior_process\"]\n    \n        linearization, implementation = linearization_implementation\n        _lin_method = {\n            \"ekf\": functools.partial(\n                filtsmooth.DiscreteEKFComponent,\n                forward_implementation=implementation,\n                backward_implementation=implementation,\n            ),\n            \"ukf\": filtsmooth.DiscreteUKFComponent,\n        }[linearization]\n    \n        self.dense_locations = np.sort(\n            np.unique(\n                np.random.uniform(\n                    low=regression_problem.locations[0],\n                    high=1.2 * regression_problem.locations[-1],\n                    size=int(1.2 * len(regression_problem.locations)),\n                )\n            )\n        )\n    \n        linearized_dynmod = _lin_method(prior_process.transition)\n        linearized_measmod = _lin_method(regression_problem.measurement_models[0])\n        regression_problem.measurement_models = [linearized_measmod] * len(\n            regression_problem.locations\n        )\n    \n        prior_process = randprocs.MarkovProcess(\n            transition=linearized_dynmod,\n            initrv=prior_process.initrv,\n            initarg=regression_problem.locations[0],\n        )\n    \n        self.kalman_filter = filtsmooth.Kalman(prior_process=prior_process)\n    \n        self.filtering_posterior, _ = self.kalman_filter.filter(regression_problem)\n        self.smoothing_posterior = self.kalman_filter.smooth(\n            filter_posterior=self.filtering_posterior\n        )",
        "min_run_count": 2,
        "name": "filtsmooth.DenseGridOperations.time_dense_smoother",
        "number": 0,
        "param_names": [
            "linearization_implementation",
            "num_samples"
        ],
        "params": [
            [
                "('ekf', 'classic')",
                "('ekf', 'sqrt')",
                "('ukf', 'classic')"
            ],
            [
                "1",
                "10"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "355f5f47c20a664ede88666478666eebb8731ae833c8c31bb33ff3143355ccc5",
        "warmup_time": -1
    },
    "filtsmooth.DenseGridOperations.time_sample": {
        "code": "class DenseGridOperations:\n    def time_sample(self, linearization_implementation, num_samples):\n        self.smoothing_posterior.sample(t=self.dense_locations, size=num_samples)\n\n    def setup(self, linearization_implementation, num_samples):\n        measvar = 0.1024\n        initrv = randvars.Normal(np.ones(2), measvar * np.eye(2))\n        regression_problem, info = filtsmooth_zoo.pendulum(\n            measurement_variance=measvar,\n            timespan=(0.0, 4.0),\n            step=0.0075,\n            initrv=initrv,\n        )\n        prior_process = info[\"prior_process\"]\n    \n        linearization, implementation = linearization_implementation\n        _lin_method = {\n            \"ekf\": functools.partial(\n                filtsmooth.DiscreteEKFComponent,\n                forward_implementation=implementation,\n                backward_implementation=implementation,\n            ),\n            \"ukf\": filtsmooth.DiscreteUKFComponent,\n        }[linearization]\n    \n        self.dense_locations = np.sort(\n            np.unique(\n                np.random.uniform(\n                    low=regression_problem.locations[0],\n                    high=1.2 * regression_problem.locations[-1],\n                    size=int(1.2 * len(regression_problem.locations)),\n                )\n            )\n        )\n    \n        linearized_dynmod = _lin_method(prior_process.transition)\n        linearized_measmod = _lin_method(regression_problem.measurement_models[0])\n        regression_problem.measurement_models = [linearized_measmod] * len(\n            regression_problem.locations\n        )\n    \n        prior_process = randprocs.MarkovProcess(\n            transition=linearized_dynmod,\n            initrv=prior_process.initrv,\n            initarg=regression_problem.locations[0],\n        )\n    \n        self.kalman_filter = filtsmooth.Kalman(prior_process=prior_process)\n    \n        self.filtering_posterior, _ = self.kalman_filter.filter(regression_problem)\n        self.smoothing_posterior = self.kalman_filter.smooth(\n            filter_posterior=self.filtering_posterior\n        )",
        "min_run_count": 2,
        "name": "filtsmooth.DenseGridOperations.time_sample",
        "number": 0,
        "param_names": [
            "linearization_implementation",
            "num_samples"
        ],
        "params": [
            [
                "('ekf', 'classic')",
                "('ekf', 'sqrt')",
                "('ukf', 'classic')"
            ],
            [
                "1",
                "10"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "83f911c549f4bf54b5c981f4fbf9988cbf4f5881585cc47c4642e031b2e94321",
        "warmup_time": -1
    },
    "filtsmooth.Filtering.peakmem_filter": {
        "code": "class Filtering:\n    def peakmem_filter(self, linearization_implementation):\n        self.kalman_filter.filter(self.regression_problem)\n\n    def setup(self, linearization_implementation):\n        measvar = 0.1024\n        initrv = randvars.Normal(np.ones(2), measvar * np.eye(2))\n        regression_problem, info = filtsmooth_zoo.pendulum(\n            measurement_variance=measvar,\n            timespan=(0.0, 4.0),\n            step=0.0075,\n            initrv=initrv,\n        )\n        prior_process = info[\"prior_process\"]\n    \n        linearization, implementation = linearization_implementation\n        _lin_method = {\n            \"ekf\": functools.partial(\n                filtsmooth.DiscreteEKFComponent,\n                forward_implementation=implementation,\n                backward_implementation=implementation,\n            ),\n            \"ukf\": filtsmooth.DiscreteUKFComponent,\n        }[linearization]\n    \n        linearized_dynmod = _lin_method(prior_process.transition)\n        linearized_measmod = _lin_method(regression_problem.measurement_models[0])\n        regression_problem.measurement_models = [linearized_measmod] * len(\n            regression_problem.locations\n        )\n    \n        prior_process = randprocs.MarkovProcess(\n            transition=linearized_dynmod,\n            initrv=prior_process.initrv,\n            initarg=regression_problem.locations[0],\n        )\n        self.regression_problem = regression_problem\n    \n        self.kalman_filter = filtsmooth.Kalman(prior_process=prior_process)",
        "name": "filtsmooth.Filtering.peakmem_filter",
        "param_names": [
            "linearization_implementation"
        ],
        "params": [
            [
                "('ekf', 'classic')",
                "('ekf', 'sqrt')",
                "('ukf', 'classic')"
            ]
        ],
        "timeout": 60.0,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "8c5aaf751518744d07a6fc4f593adbad57c101c97caae686555caf642ec7ed22"
    },
    "filtsmooth.Filtering.time_filter": {
        "code": "class Filtering:\n    def time_filter(self, linearization_implementation):\n        self.kalman_filter.filter(self.regression_problem)\n\n    def setup(self, linearization_implementation):\n        measvar = 0.1024\n        initrv = randvars.Normal(np.ones(2), measvar * np.eye(2))\n        regression_problem, info = filtsmooth_zoo.pendulum(\n            measurement_variance=measvar,\n            timespan=(0.0, 4.0),\n            step=0.0075,\n            initrv=initrv,\n        )\n        prior_process = info[\"prior_process\"]\n    \n        linearization, implementation = linearization_implementation\n        _lin_method = {\n            \"ekf\": functools.partial(\n                filtsmooth.DiscreteEKFComponent,\n                forward_implementation=implementation,\n                backward_implementation=implementation,\n            ),\n            \"ukf\": filtsmooth.DiscreteUKFComponent,\n        }[linearization]\n    \n        linearized_dynmod = _lin_method(prior_process.transition)\n        linearized_measmod = _lin_method(regression_problem.measurement_models[0])\n        regression_problem.measurement_models = [linearized_measmod] * len(\n            regression_problem.locations\n        )\n    \n        prior_process = randprocs.MarkovProcess(\n            transition=linearized_dynmod,\n            initrv=prior_process.initrv,\n            initarg=regression_problem.locations[0],\n        )\n        self.regression_problem = regression_problem\n    \n        self.kalman_filter = filtsmooth.Kalman(prior_process=prior_process)",
        "min_run_count": 2,
        "name": "filtsmooth.Filtering.time_filter",
        "number": 0,
        "param_names": [
            "linearization_implementation"
        ],
        "params": [
            [
                "('ekf', 'classic')",
                "('ekf', 'sqrt')",
                "('ukf', 'classic')"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "dd0f7f77ede1747e14a338d0073ff40055852e19d5c3fe15c175a5c7c2fbc68e",
        "warmup_time": -1
    },
    "filtsmooth.Smoothing.peakmem_smooth": {
        "code": "class Smoothing:\n    def peakmem_smooth(self, linearization_implementation):\n        self.kalman_filter.smooth(filter_posterior=self.filtering_posterior)\n\n    def setup(self, linearization_implementation):\n        measvar = 0.1024\n        initrv = randvars.Normal(np.ones(2), measvar * np.eye(2))\n        regression_problem, info = filtsmooth_zoo.pendulum(\n            measurement_variance=measvar,\n            timespan=(0.0, 4.0),\n            step=0.0075,\n            initrv=initrv,\n        )\n        prior_process = info[\"prior_process\"]\n    \n        linearization, implementation = linearization_implementation\n        _lin_method = {\n            \"ekf\": functools.partial(\n                filtsmooth.DiscreteEKFComponent,\n                forward_implementation=implementation,\n                backward_implementation=implementation,\n            ),\n            \"ukf\": filtsmooth.DiscreteUKFComponent,\n        }[linearization]\n    \n        linearized_dynmod = _lin_method(prior_process.transition)\n        linearized_measmod = _lin_method(regression_problem.measurement_models[0])\n        regression_problem.measurement_models = [linearized_measmod] * len(\n            regression_problem.locations\n        )\n    \n        prior_process = randprocs.MarkovProcess(\n            transition=linearized_dynmod,\n            initrv=prior_process.initrv,\n            initarg=regression_problem.locations[0],\n        )\n    \n        self.kalman_filter = filtsmooth.Kalman(prior_process=prior_process)\n        self.filtering_posterior, _ = self.kalman_filter.filter(regression_problem)",
        "name": "filtsmooth.Smoothing.peakmem_smooth",
        "param_names": [
            "linearization_implementation"
        ],
        "params": [
            [
                "('ekf', 'classic')",
                "('ekf', 'sqrt')",
                "('ukf', 'classic')"
            ]
        ],
        "timeout": 60.0,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "9f6bdd847bdf31905255f156059df507e7f43961fa343260929e7283efd9c8fc"
    },
    "filtsmooth.Smoothing.time_smooth": {
        "code": "class Smoothing:\n    def time_smooth(self, linearization_implementation):\n        self.kalman_filter.smooth(filter_posterior=self.filtering_posterior)\n\n    def setup(self, linearization_implementation):\n        measvar = 0.1024\n        initrv = randvars.Normal(np.ones(2), measvar * np.eye(2))\n        regression_problem, info = filtsmooth_zoo.pendulum(\n            measurement_variance=measvar,\n            timespan=(0.0, 4.0),\n            step=0.0075,\n            initrv=initrv,\n        )\n        prior_process = info[\"prior_process\"]\n    \n        linearization, implementation = linearization_implementation\n        _lin_method = {\n            \"ekf\": functools.partial(\n                filtsmooth.DiscreteEKFComponent,\n                forward_implementation=implementation,\n                backward_implementation=implementation,\n            ),\n            \"ukf\": filtsmooth.DiscreteUKFComponent,\n        }[linearization]\n    \n        linearized_dynmod = _lin_method(prior_process.transition)\n        linearized_measmod = _lin_method(regression_problem.measurement_models[0])\n        regression_problem.measurement_models = [linearized_measmod] * len(\n            regression_problem.locations\n        )\n    \n        prior_process = randprocs.MarkovProcess(\n            transition=linearized_dynmod,\n            initrv=prior_process.initrv,\n            initarg=regression_problem.locations[0],\n        )\n    \n        self.kalman_filter = filtsmooth.Kalman(prior_process=prior_process)\n        self.filtering_posterior, _ = self.kalman_filter.filter(regression_problem)",
        "min_run_count": 2,
        "name": "filtsmooth.Smoothing.time_smooth",
        "number": 0,
        "param_names": [
            "linearization_implementation"
        ],
        "params": [
            [
                "('ekf', 'classic')",
                "('ekf', 'sqrt')",
                "('ukf', 'classic')"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "74d655343757ab367fd9a48e0802bd1e4cfa173cd34c3f0ce85bfee7305abbef",
        "warmup_time": -1
    },
    "ivpsolvers.IVPSolve.peakmem_solve": {
        "code": "class IVPSolve:\n    def peakmem_solve(self, method, algo_order):\n        f = self.ivp.rhs\n        df = self.ivp.jacobian\n        t0, tmax = self.ivp.timespan\n        y0 = self.ivp.initrv.mean\n        probsolve_ivp(\n            f,\n            t0,\n            tmax,\n            y0,\n            df=df,\n            method=method,\n            dense_output=True,\n            algo_order=algo_order,\n            step=self.stepsize,\n            adaptive=False,\n        )\n\n    def setup(self, method, prior):\n        # pylint: disable=invalid-name\n        self.ivp = load_lotkavolterra()\n        self.stepsize = 1e-1",
        "name": "ivpsolvers.IVPSolve.peakmem_solve",
        "param_names": [
            "method",
            "algo_order"
        ],
        "params": [
            [
                "'ek0'",
                "'ek1'"
            ],
            [
                "2",
                "3"
            ]
        ],
        "timeout": 60.0,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "4355f33a1226e75a219f8222b8472582c26e9fdc3d9d2488e7343b952fa3000e"
    },
    "ivpsolvers.IVPSolve.time_solve": {
        "code": "class IVPSolve:\n    def time_solve(self, method, algo_order):\n        f = self.ivp.rhs\n        df = self.ivp.jacobian\n        t0, tmax = self.ivp.timespan\n        y0 = self.ivp.initrv.mean\n        probsolve_ivp(\n            f,\n            t0,\n            tmax,\n            y0,\n            df=df,\n            method=method,\n            dense_output=True,\n            algo_order=algo_order,\n            step=self.stepsize,\n            adaptive=False,\n        )\n\n    def setup(self, method, prior):\n        # pylint: disable=invalid-name\n        self.ivp = load_lotkavolterra()\n        self.stepsize = 1e-1",
        "min_run_count": 2,
        "name": "ivpsolvers.IVPSolve.time_solve",
        "number": 0,
        "param_names": [
            "method",
            "algo_order"
        ],
        "params": [
            [
                "'ek0'",
                "'ek1'"
            ],
            [
                "2",
                "3"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "6a79b92752b388b6b1c46d5394b9d6f4baf0e5455b6d5de65510fdb0e923bf9d",
        "warmup_time": -1
    },
    "kernels.Kernels.peakmem_kernel_matrix": {
        "code": "class Kernels:\n    def peakmem_kernel_matrix(self, kernel, n_datapoints):\n        \"\"\"Peak memory of sampling process.\"\"\"\n        self.kernel(self.data)\n\n    def setup(self, kernel, n_datapoints):\n        rng = np.random.default_rng(42)\n        self.input_dim = 100\n        self.data = rng.normal(size=(n_datapoints, self.input_dim))\n        self.kernel = get_kernel(kernel_name=kernel, input_dim=self.input_dim)",
        "name": "kernels.Kernels.peakmem_kernel_matrix",
        "param_names": [
            "kernel",
            "n_datapoints"
        ],
        "params": [
            [
                "'white_noise'",
                "'linear'",
                "'polynomial'",
                "'exp_quad'",
                "'rat_quad'",
                "'matern12'",
                "'matern32'",
                "'matern52'",
                "'matern72'"
            ],
            [
                "10",
                "100",
                "1000"
            ]
        ],
        "timeout": 60.0,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "b4f420e1ef1214a865c6f026feb39a43143f57a26b361623fb63418e2f0a01b1"
    },
    "kernels.Kernels.time_kernel_matrix": {
        "code": "class Kernels:\n    def time_kernel_matrix(self, kernel, n_datapoints):\n        \"\"\"Times sampling from this distribution.\"\"\"\n        self.kernel(self.data)\n\n    def setup(self, kernel, n_datapoints):\n        rng = np.random.default_rng(42)\n        self.input_dim = 100\n        self.data = rng.normal(size=(n_datapoints, self.input_dim))\n        self.kernel = get_kernel(kernel_name=kernel, input_dim=self.input_dim)",
        "min_run_count": 2,
        "name": "kernels.Kernels.time_kernel_matrix",
        "number": 0,
        "param_names": [
            "kernel",
            "n_datapoints"
        ],
        "params": [
            [
                "'white_noise'",
                "'linear'",
                "'polynomial'",
                "'exp_quad'",
                "'rat_quad'",
                "'matern12'",
                "'matern32'",
                "'matern52'",
                "'matern72'"
            ],
            [
                "10",
                "100",
                "1000"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "bd80bb62c96bc059c77c591c8a2f9c501cce5fe29dd92efb750ce55f0ada226e",
        "warmup_time": -1
    },
    "linearsolvers.LinSolve.mem_solve": {
        "code": "class LinSolve:\n    def mem_solve(self, system):\n        \"\"\"Time solving a linear system.\"\"\"\n        problinsolve(A=self.A, b=self.b)\n\n    def setup(self, system):\n        # Seed\n        np.random.seed(42)\n    \n        if system == \"sparse\":\n            (\n                self.A,\n                self.b,\n            ) = load_poisson_linear_system()\n        elif system == \"dense\":\n            self.A = SPD_MATRIX_5x5\n            self.b = np.random.normal(size=self.A.shape[0])\n        elif system == \"large-scale\":\n            self.A = None\n            self.b = None",
        "name": "linearsolvers.LinSolve.mem_solve",
        "param_names": [
            "system"
        ],
        "params": [
            [
                "'sparse'",
                "'dense'"
            ]
        ],
        "timeout": 60.0,
        "type": "memory",
        "unit": "bytes",
        "version": "339b33f3828c63a96101d46a5fc0516e96c6493bd4c7299a1d1de5ae414517ff"
    },
    "linearsolvers.LinSolve.peakmem_solve": {
        "code": "class LinSolve:\n    def peakmem_solve(self, system):\n        \"\"\"Time solving a linear system.\"\"\"\n        problinsolve(A=self.A, b=self.b)\n\n    def setup(self, system):\n        # Seed\n        np.random.seed(42)\n    \n        if system == \"sparse\":\n            (\n                self.A,\n                self.b,\n            ) = load_poisson_linear_system()\n        elif system == \"dense\":\n            self.A = SPD_MATRIX_5x5\n            self.b = np.random.normal(size=self.A.shape[0])\n        elif system == \"large-scale\":\n            self.A = None\n            self.b = None",
        "name": "linearsolvers.LinSolve.peakmem_solve",
        "param_names": [
            "system"
        ],
        "params": [
            [
                "'sparse'",
                "'dense'"
            ]
        ],
        "timeout": 60.0,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "6647c7e69e7c7de96befd7f8e9df8d0cbef4865c223a4c915786b12c84cb92c2"
    },
    "linearsolvers.LinSolve.time_solve": {
        "code": "class LinSolve:\n    def time_solve(self, system):\n        \"\"\"Time solving a linear system.\"\"\"\n        problinsolve(A=self.A, b=self.b)\n\n    def setup(self, system):\n        # Seed\n        np.random.seed(42)\n    \n        if system == \"sparse\":\n            (\n                self.A,\n                self.b,\n            ) = load_poisson_linear_system()\n        elif system == \"dense\":\n            self.A = SPD_MATRIX_5x5\n            self.b = np.random.normal(size=self.A.shape[0])\n        elif system == \"large-scale\":\n            self.A = None\n            self.b = None",
        "min_run_count": 2,
        "name": "linearsolvers.LinSolve.time_solve",
        "number": 0,
        "param_names": [
            "system"
        ],
        "params": [
            [
                "'sparse'",
                "'dense'"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "00e14040e21d8eb565e633cf998a4aa266616e92f9a884480a4cb8dd4050545a",
        "warmup_time": -1
    },
    "linearsolvers.PosteriorDist.time_sample": {
        "code": "class PosteriorDist:\n    def time_sample(self, output):\n        \"\"\"Time sampling from the posterior distribution.\"\"\"\n        if output == \"solution\":\n            self.xhat.sample(self.n_samples)\n        elif output == \"matrix\":\n            self.Ahat.sample(self.n_samples)\n        elif output == \"matrix_inverse\":\n            self.Ainvhat.sample(self.n_samples)\n\n    def setup(self, output):\n        # pylint: disable=invalid-name\n    \n        # Sparse system\n        self.A, self.b = load_poisson_linear_system()\n    \n        # Solve linear system\n        self.xhat, self.Ahat, self.Ainvhat, _ = problinsolve(A=self.A, b=self.b)\n    \n        # Benchmark parameters\n        self.n_samples = 10",
        "min_run_count": 2,
        "name": "linearsolvers.PosteriorDist.time_sample",
        "number": 0,
        "param_names": [
            "output"
        ],
        "params": [
            [
                "'solution'",
                "'matrix'",
                "'matrix_inverse'"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "da540442fa5cdd201a5b76df0ad91f4ffcd4c63dee83a54c466fe9079ff0ef4d",
        "warmup_time": -1
    },
    "linops.Cond.peakmem_cond": {
        "code": "class Cond:\n    def peakmem_cond(self, operator: str, p):\n        self.linop.cond(p=p)\n\n    def setup(self, operator: str, p):\n        np.random.seed(42)\n    \n        if operator in NO_COND[p]:\n            raise NotImplementedError()\n    \n        self.linop = get_linear_operator(operator)",
        "name": "linops.Cond.peakmem_cond",
        "param_names": [
            "operator",
            "p"
        ],
        "params": [
            [
                "'matrix'",
                "'matrix_sparse'",
                "'identity'",
                "'isotropic_scaling'",
                "'anisotropic_scaling'",
                "'kronecker'",
                "'symmetric_kronecker_distinct_factors'",
                "'symmetric_kronecker_identical_factors'"
            ],
            [
                "2",
                "'fro'",
                "1",
                "inf"
            ]
        ],
        "timeout": 60.0,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "de1c7de85ed1e087b13267ea364dcb4cd32dba38932bed7f4a2c0882a7eb2eee"
    },
    "linops.Cond.time_cond": {
        "code": "class Cond:\n    def time_cond(self, operator: str, p):\n        self.linop.cond(p=p)\n\n    def setup(self, operator: str, p):\n        np.random.seed(42)\n    \n        if operator in NO_COND[p]:\n            raise NotImplementedError()\n    \n        self.linop = get_linear_operator(operator)",
        "min_run_count": 2,
        "name": "linops.Cond.time_cond",
        "number": 0,
        "param_names": [
            "operator",
            "p"
        ],
        "params": [
            [
                "'matrix'",
                "'matrix_sparse'",
                "'identity'",
                "'isotropic_scaling'",
                "'anisotropic_scaling'",
                "'kronecker'",
                "'symmetric_kronecker_distinct_factors'",
                "'symmetric_kronecker_identical_factors'"
            ],
            [
                "2",
                "'fro'",
                "1",
                "inf"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "631616ea7ae3a99fc7663f184c65dcaa0cc9d7c676124dd895aef0e527f62dce",
        "warmup_time": -1
    },
    "linops.Construction.peakmem_matvec": {
        "code": "class Construction:\n    def peakmem_matvec(self, operator: str):\n        get_linear_operator(operator)\n\n    def setup(self, operator: str):\n        np.random.seed(42)",
        "name": "linops.Construction.peakmem_matvec",
        "param_names": [
            "operator"
        ],
        "params": [
            [
                "'matrix'",
                "'matrix_sparse'",
                "'identity'",
                "'isotropic_scaling'",
                "'anisotropic_scaling'",
                "'kronecker'",
                "'symmetric_kronecker_distinct_factors'",
                "'symmetric_kronecker_identical_factors'"
            ]
        ],
        "timeout": 60.0,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "ae87a369dcccf6af4c938b268cd8228960e7357b16e4f2fbd91d85b5203d8e7c"
    },
    "linops.Construction.time_construction": {
        "code": "class Construction:\n    def time_construction(self, operator: str):\n        get_linear_operator(operator)\n\n    def setup(self, operator: str):\n        np.random.seed(42)",
        "min_run_count": 2,
        "name": "linops.Construction.time_construction",
        "number": 0,
        "param_names": [
            "operator"
        ],
        "params": [
            [
                "'matrix'",
                "'matrix_sparse'",
                "'identity'",
                "'isotropic_scaling'",
                "'anisotropic_scaling'",
                "'kronecker'",
                "'symmetric_kronecker_distinct_factors'",
                "'symmetric_kronecker_identical_factors'"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "a30599dfc07b2fc54d7dd57b61f6f291d5be098be4561d33c6a4cfe87f727eee",
        "warmup_time": -1
    },
    "linops.Det.peakmem_det": {
        "code": "class Det:\n    def peakmem_det(self, operator: str):\n        self.linop.det()\n\n    def setup(self, operator: str):\n        np.random.seed(42)\n    \n        if operator in NO_DET:\n            raise NotImplementedError()\n    \n        self.linop = get_linear_operator(operator)",
        "name": "linops.Det.peakmem_det",
        "param_names": [
            "operator"
        ],
        "params": [
            [
                "'matrix'",
                "'matrix_sparse'",
                "'identity'",
                "'isotropic_scaling'",
                "'anisotropic_scaling'",
                "'kronecker'",
                "'symmetric_kronecker_distinct_factors'",
                "'symmetric_kronecker_identical_factors'"
            ]
        ],
        "timeout": 60.0,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "0f7b7734cc4aae667f7420eb65bec0e2a8d93ace2b3ea9fcb0843c36db15df16"
    },
    "linops.Det.time_det": {
        "code": "class Det:\n    def time_det(self, operator: str):\n        self.linop.det()\n\n    def setup(self, operator: str):\n        np.random.seed(42)\n    \n        if operator in NO_DET:\n            raise NotImplementedError()\n    \n        self.linop = get_linear_operator(operator)",
        "min_run_count": 2,
        "name": "linops.Det.time_det",
        "number": 0,
        "param_names": [
            "operator"
        ],
        "params": [
            [
                "'matrix'",
                "'matrix_sparse'",
                "'identity'",
                "'isotropic_scaling'",
                "'anisotropic_scaling'",
                "'kronecker'",
                "'symmetric_kronecker_distinct_factors'",
                "'symmetric_kronecker_identical_factors'"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "0c2242d4f54ee8a7e2a11f686e600bfaeeb88693a5f6bc7411c207cbb3790bc1",
        "warmup_time": -1
    },
    "linops.Eigvals.peakmem_eigvals": {
        "code": "class Eigvals:\n    def peakmem_eigvals(self, operator: str):\n        self.linop.eigvals()\n\n    def setup(self, operator: str):\n        np.random.seed(42)\n    \n        if operator in NO_EIGVALS:\n            raise NotImplementedError()\n    \n        self.linop = get_linear_operator(operator)",
        "name": "linops.Eigvals.peakmem_eigvals",
        "param_names": [
            "operator"
        ],
        "params": [
            [
                "'matrix'",
                "'matrix_sparse'",
                "'identity'",
                "'isotropic_scaling'",
                "'anisotropic_scaling'",
                "'kronecker'",
                "'symmetric_kronecker_distinct_factors'",
                "'symmetric_kronecker_identical_factors'"
            ]
        ],
        "timeout": 60.0,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "5e2311b3426897501464fb49abb571222d9019bb1365d1fa2fa43e067c966c82"
    },
    "linops.Eigvals.time_eigvals": {
        "code": "class Eigvals:\n    def time_eigvals(self, operator: str):\n        self.linop.eigvals()\n\n    def setup(self, operator: str):\n        np.random.seed(42)\n    \n        if operator in NO_EIGVALS:\n            raise NotImplementedError()\n    \n        self.linop = get_linear_operator(operator)",
        "min_run_count": 2,
        "name": "linops.Eigvals.time_eigvals",
        "number": 0,
        "param_names": [
            "operator"
        ],
        "params": [
            [
                "'matrix'",
                "'matrix_sparse'",
                "'identity'",
                "'isotropic_scaling'",
                "'anisotropic_scaling'",
                "'kronecker'",
                "'symmetric_kronecker_distinct_factors'",
                "'symmetric_kronecker_identical_factors'"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "2a12534450fb9e4be1b0423e92b87d90d118d53107b12c60535b8819583479b2",
        "warmup_time": -1
    },
    "linops.LogAbsDet.peakmem_logabsdet": {
        "code": "class LogAbsDet:\n    def peakmem_logabsdet(self, operator: str):\n        self.linop.logabsdet()\n\n    def setup(self, operator: str):\n        np.random.seed(42)\n    \n        if operator in NO_LOGABSDET:\n            raise NotImplementedError()\n    \n        self.linop = get_linear_operator(operator)",
        "name": "linops.LogAbsDet.peakmem_logabsdet",
        "param_names": [
            "operator"
        ],
        "params": [
            [
                "'matrix'",
                "'matrix_sparse'",
                "'identity'",
                "'isotropic_scaling'",
                "'anisotropic_scaling'",
                "'kronecker'",
                "'symmetric_kronecker_distinct_factors'",
                "'symmetric_kronecker_identical_factors'"
            ]
        ],
        "timeout": 60.0,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "ff6088730132a29b2e64db868896fed674ecf65fa182e5c6058ac28033d7b895"
    },
    "linops.LogAbsDet.time_logabsdet": {
        "code": "class LogAbsDet:\n    def time_logabsdet(self, operator: str):\n        self.linop.logabsdet()\n\n    def setup(self, operator: str):\n        np.random.seed(42)\n    \n        if operator in NO_LOGABSDET:\n            raise NotImplementedError()\n    \n        self.linop = get_linear_operator(operator)",
        "min_run_count": 2,
        "name": "linops.LogAbsDet.time_logabsdet",
        "number": 0,
        "param_names": [
            "operator"
        ],
        "params": [
            [
                "'matrix'",
                "'matrix_sparse'",
                "'identity'",
                "'isotropic_scaling'",
                "'anisotropic_scaling'",
                "'kronecker'",
                "'symmetric_kronecker_distinct_factors'",
                "'symmetric_kronecker_identical_factors'"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "673ebc1bf2101999d0cfcddf5a345f5e1e566000367d6186ea2117dfe35143a7",
        "warmup_time": -1
    },
    "linops.MatMat.peakmem_matmat": {
        "code": "class MatMat:\n    def peakmem_matmat(self, operator: str):\n        _ = self.linop @ self.mat\n\n    def setup(self, operator: str):\n        np.random.seed(42)\n    \n        self.linop = get_linear_operator(operator)\n        self.mat = np.ones(\n            (self.linop.shape[1], 1000), dtype=self.linop.dtype, order=\"F\"\n        )",
        "name": "linops.MatMat.peakmem_matmat",
        "param_names": [
            "operator"
        ],
        "params": [
            [
                "'matrix'",
                "'matrix_sparse'",
                "'identity'",
                "'isotropic_scaling'",
                "'anisotropic_scaling'",
                "'kronecker'",
                "'symmetric_kronecker_distinct_factors'",
                "'symmetric_kronecker_identical_factors'"
            ]
        ],
        "timeout": 60.0,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "a67815b3c335e81aaf6e577d2c5f75f8f43de98717463b518c6cdfe0ccf72ef6"
    },
    "linops.MatMat.time_matmat": {
        "code": "class MatMat:\n    def time_matmat(self, operator: str):\n        _ = self.linop @ self.mat\n\n    def setup(self, operator: str):\n        np.random.seed(42)\n    \n        self.linop = get_linear_operator(operator)\n        self.mat = np.ones(\n            (self.linop.shape[1], 1000), dtype=self.linop.dtype, order=\"F\"\n        )",
        "min_run_count": 2,
        "name": "linops.MatMat.time_matmat",
        "number": 0,
        "param_names": [
            "operator"
        ],
        "params": [
            [
                "'matrix'",
                "'matrix_sparse'",
                "'identity'",
                "'isotropic_scaling'",
                "'anisotropic_scaling'",
                "'kronecker'",
                "'symmetric_kronecker_distinct_factors'",
                "'symmetric_kronecker_identical_factors'"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "56c6cafbf6cef4adf5006c7a1a0521b50bae2061dd48d6b6c3282747c7bcb0f0",
        "warmup_time": -1
    },
    "linops.MatVec.peakmem_matvec": {
        "code": "class MatVec:\n    def peakmem_matvec(self, operator: str):\n        _ = self.linop @ self.vec\n\n    def setup(self, operator: str):\n        np.random.seed(42)\n    \n        self.linop = get_linear_operator(operator)\n        self.vec = np.ones(self.linop.shape[1], dtype=self.linop.dtype)",
        "name": "linops.MatVec.peakmem_matvec",
        "param_names": [
            "operator"
        ],
        "params": [
            [
                "'matrix'",
                "'matrix_sparse'",
                "'identity'",
                "'isotropic_scaling'",
                "'anisotropic_scaling'",
                "'kronecker'",
                "'symmetric_kronecker_distinct_factors'",
                "'symmetric_kronecker_identical_factors'"
            ]
        ],
        "timeout": 60.0,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "870528f5173e3432055cbaf18a1613f907a2ff2557a5fbdce0b48fa69f0c0065"
    },
    "linops.MatVec.time_matvec": {
        "code": "class MatVec:\n    def time_matvec(self, operator: str):\n        _ = self.linop @ self.vec\n\n    def setup(self, operator: str):\n        np.random.seed(42)\n    \n        self.linop = get_linear_operator(operator)\n        self.vec = np.ones(self.linop.shape[1], dtype=self.linop.dtype)",
        "min_run_count": 2,
        "name": "linops.MatVec.time_matvec",
        "number": 0,
        "param_names": [
            "operator"
        ],
        "params": [
            [
                "'matrix'",
                "'matrix_sparse'",
                "'identity'",
                "'isotropic_scaling'",
                "'anisotropic_scaling'",
                "'kronecker'",
                "'symmetric_kronecker_distinct_factors'",
                "'symmetric_kronecker_identical_factors'"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "cd9c1dd865449e5810e461b20ca04b8d8bc53c21ca294bda571d2645afece784",
        "warmup_time": -1
    },
    "linops.Rank.peakmem_rank": {
        "code": "class Rank:\n    def peakmem_rank(self, operator: str):\n        self.linop.rank()\n\n    def setup(self, operator: str):\n        np.random.seed(42)\n    \n        if operator in NO_RANK:\n            raise NotImplementedError()\n    \n        self.linop = get_linear_operator(operator)",
        "name": "linops.Rank.peakmem_rank",
        "param_names": [
            "operator"
        ],
        "params": [
            [
                "'matrix'",
                "'matrix_sparse'",
                "'identity'",
                "'isotropic_scaling'",
                "'anisotropic_scaling'",
                "'kronecker'",
                "'symmetric_kronecker_distinct_factors'",
                "'symmetric_kronecker_identical_factors'"
            ]
        ],
        "timeout": 60.0,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "a936825e1c63c8e988eddadac78ef6b3fe26a92aacf25a17915ee1bcf0cf7758"
    },
    "linops.Rank.time_rank": {
        "code": "class Rank:\n    def time_rank(self, operator: str):\n        self.linop.rank()\n\n    def setup(self, operator: str):\n        np.random.seed(42)\n    \n        if operator in NO_RANK:\n            raise NotImplementedError()\n    \n        self.linop = get_linear_operator(operator)",
        "min_run_count": 2,
        "name": "linops.Rank.time_rank",
        "number": 0,
        "param_names": [
            "operator"
        ],
        "params": [
            [
                "'matrix'",
                "'matrix_sparse'",
                "'identity'",
                "'isotropic_scaling'",
                "'anisotropic_scaling'",
                "'kronecker'",
                "'symmetric_kronecker_distinct_factors'",
                "'symmetric_kronecker_identical_factors'"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "c2e4bd0b1fffac9da7371c0a548285b8966878da14c48b3549fd4a674f4d15b0",
        "warmup_time": -1
    },
    "linops.Trace.peakmem_trace": {
        "code": "class Trace:\n    def peakmem_trace(self, operator: str):\n        self.linop.trace()\n\n    def setup(self, operator: str):\n        np.random.seed(42)\n    \n        if operator in NO_TRACE:\n            raise NotImplementedError()\n    \n        self.linop = get_linear_operator(operator)",
        "name": "linops.Trace.peakmem_trace",
        "param_names": [
            "operator"
        ],
        "params": [
            [
                "'matrix'",
                "'matrix_sparse'",
                "'identity'",
                "'isotropic_scaling'",
                "'anisotropic_scaling'",
                "'kronecker'",
                "'symmetric_kronecker_distinct_factors'",
                "'symmetric_kronecker_identical_factors'"
            ]
        ],
        "timeout": 60.0,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "396ce90079c28a6a9c124c215a13a4cfe6b980dc09f35fc4ff4079af1353c5fd"
    },
    "linops.Trace.time_trace": {
        "code": "class Trace:\n    def time_trace(self, operator: str):\n        self.linop.trace()\n\n    def setup(self, operator: str):\n        np.random.seed(42)\n    \n        if operator in NO_TRACE:\n            raise NotImplementedError()\n    \n        self.linop = get_linear_operator(operator)",
        "min_run_count": 2,
        "name": "linops.Trace.time_trace",
        "number": 0,
        "param_names": [
            "operator"
        ],
        "params": [
            [
                "'matrix'",
                "'matrix_sparse'",
                "'identity'",
                "'isotropic_scaling'",
                "'anisotropic_scaling'",
                "'kronecker'",
                "'symmetric_kronecker_distinct_factors'",
                "'symmetric_kronecker_identical_factors'"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "ccb41a2f40430f0a7ab8e86147d9d890a75858e4828034dea3863de3714e8a50",
        "warmup_time": -1
    },
    "random_variables.Functions.time_distr_functions": {
        "code": "class Functions:\n    def time_distr_functions(self, randvar, method):\n        \"\"\"Times evaluation of the pdf, logpdf, cdf and logcdf.\"\"\"\n        try:\n            if method == \"pdf\":\n                self.randvar.pdf(x=self.eval_point)\n            elif method == \"logpdf\":\n                self.randvar.logpdf(x=self.eval_point)\n            elif method == \"cdf\":\n                self.randvar.cdf(x=self.quantile)\n            elif method == \"logcdf\":\n                self.randvar.logcdf(x=self.quantile)\n        except NotImplementedError:\n            pass\n\n    def setup(self, randvar, method):\n        self.randvar = get_randvar(rv_name=randvar)\n        self.eval_point = np.random.uniform(size=self.randvar.shape)\n        self.quantile = np.random.uniform(size=self.randvar.shape)",
        "min_run_count": 2,
        "name": "random_variables.Functions.time_distr_functions",
        "number": 0,
        "param_names": [
            "randvar",
            "method"
        ],
        "params": [
            [
                "'univar_normal'",
                "'multivar_normal'",
                "'matrixvar_normal'",
                "'symmatrixvar_normal'",
                "'operatorvar_normal'"
            ],
            [
                "'pdf'",
                "'logpdf'",
                "'cdf'",
                "'logcdf'"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "7e411912776b427b31a26b16d9bb33e49fba6bef3e1d49b79641f7b2138e2ff9",
        "warmup_time": -1
    },
    "random_variables.Sampling.peakmem_sample": {
        "code": "class Sampling:\n    def peakmem_sample(self, randvar):\n        \"\"\"Peak memory of sampling process.\"\"\"\n        self.randvar.sample(self.n_samples)\n\n    def setup(self, randvar):\n        np.random.seed(42)\n        self.n_samples = 1000\n        self.randvar = get_randvar(rv_name=randvar)",
        "name": "random_variables.Sampling.peakmem_sample",
        "param_names": [
            "randvar"
        ],
        "params": [
            [
                "'univar_normal'",
                "'multivar_normal'",
                "'matrixvar_normal'",
                "'symmatrixvar_normal'",
                "'operatorvar_normal'"
            ]
        ],
        "timeout": 60.0,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "8c7bfdb1e4a4015a16a3a6d46e1f74176aef0e16995f157e92bdbf632c6326d1"
    },
    "random_variables.Sampling.time_sample": {
        "code": "class Sampling:\n    def time_sample(self, randvar):\n        \"\"\"Times sampling from this distribution.\"\"\"\n        self.randvar.sample(self.n_samples)\n\n    def setup(self, randvar):\n        np.random.seed(42)\n        self.n_samples = 1000\n        self.randvar = get_randvar(rv_name=randvar)",
        "min_run_count": 2,
        "name": "random_variables.Sampling.time_sample",
        "number": 0,
        "param_names": [
            "randvar"
        ],
        "params": [
            [
                "'univar_normal'",
                "'multivar_normal'",
                "'matrixvar_normal'",
                "'symmatrixvar_normal'",
                "'operatorvar_normal'"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "27dbfe7ba451737d64221100d07633db8df65f4992b6dc037ff7e395fbbf4697",
        "warmup_time": -1
    },
    "version": 2
}