{
    "distribution.Functions.time_distr_functions": {
        "code": "class Functions:\n    def time_distr_functions(self, dist, property):\n        \"\"\"Times evaluation of the pdf, logpdf, cdf and logcdf.\"\"\"\n        try:\n            if property == \"pdf\":\n                self.randvar.distribution.pdf(x=self.eval_point)\n            elif property == \"logpdf\":\n                self.randvar.distribution.pdf(x=self.eval_point)\n            elif property == \"cdf\":\n                self.randvar.distribution.pdf(x=self.quantile)\n            elif property == \"logcdf\":\n                self.randvar.distribution.pdf(x=self.quantile)\n        except NotImplementedError:\n            pass\n\n    def setup(self, dist, property):\n        self.randvar = get_randvar(distribution_name=dist)\n        self.eval_point = np.random.uniform(self.randvar.shape)\n        self.quantile = np.random.uniform(self.randvar.shape)",
        "min_run_count": 2,
        "name": "distribution.Functions.time_distr_functions",
        "number": 0,
        "param_names": [
            "dist",
            "property"
        ],
        "params": [
            [
                "'univar_normal'",
                "'multivar_normal'",
                "'matrixvar_normal'",
                "'symmatrixvar_normal'"
            ],
            [
                "'pdf'",
                "'logpdf'",
                "'cdf'",
                "'logcdf'"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "c34be45871a81ba51db14abb809470bf779abec711211d454c4275de8f77a6b4",
        "warmup_time": -1
    },
    "distribution.Sampling.peakmem_sample": {
        "code": "class Sampling:\n    def peakmem_sample(self, dist):\n        \"\"\"Peak memory of sampling process.\"\"\"\n        self.randvar.sample(self.n_samples)\n\n    def setup(self, dist):\n        np.random.seed(42)\n        self.n_samples = 1000\n        self.randvar = get_randvar(distribution_name=dist)",
        "name": "distribution.Sampling.peakmem_sample",
        "param_names": [
            "dist"
        ],
        "params": [
            [
                "'univar_normal'",
                "'multivar_normal'",
                "'matrixvar_normal'",
                "'symmatrixvar_normal'"
            ]
        ],
        "timeout": 60.0,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "c75738772ab05552dcec0b653b26eb4397de0c750d14eea3f6e0b1afbf0a8a97"
    },
    "distribution.Sampling.time_sample": {
        "code": "class Sampling:\n    def time_sample(self, dist):\n        \"\"\"Times sampling from this distribution.\"\"\"\n        self.randvar.sample(self.n_samples)\n\n    def setup(self, dist):\n        np.random.seed(42)\n        self.n_samples = 1000\n        self.randvar = get_randvar(distribution_name=dist)",
        "min_run_count": 2,
        "name": "distribution.Sampling.time_sample",
        "number": 0,
        "param_names": [
            "dist"
        ],
        "params": [
            [
                "'univar_normal'",
                "'multivar_normal'",
                "'matrixvar_normal'",
                "'symmatrixvar_normal'"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "f20f857be1d0c0f4340e8064e5285dad677a08c3d33aa21133d190a573c4fad8",
        "warmup_time": -1
    },
    "ivpsolve.IVPSolve.peakmem_solve": {
        "code": "class IVPSolve:\n    def peakmem_solve(self, method, precond, prior):\n        precond_step = self.stepsize if precond == \"with\" else 1.0\n        probsolve_ivp(\n            self.ivp,\n            method=method,\n            which_prior=prior,\n            step=self.stepsize,\n            precond_step=precond_step,\n        )\n\n    def setup(self, method, precond, prior):\n        self.ivp = load_lotkavolterra()\n        self.stepsize = 1e-2",
        "name": "ivpsolve.IVPSolve.peakmem_solve",
        "param_names": [
            "method",
            "precond",
            "prior"
        ],
        "params": [
            [
                "'eks0'",
                "'ekf0'"
            ],
            [
                "'with'",
                "'without'"
            ],
            [
                "'ibm4'",
                "'ioup4'",
                "'matern92'"
            ]
        ],
        "timeout": 60.0,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "f460649f4516df7bc424e4f0350b7cfc2dd208230e9c06d8285491593988f934"
    },
    "ivpsolve.IVPSolve.time_solve": {
        "code": "class IVPSolve:\n    def time_solve(self, method, precond, prior):\n        precond_step = self.stepsize if precond == \"with\" else 1.0\n        probsolve_ivp(\n            self.ivp,\n            method=method,\n            which_prior=prior,\n            step=self.stepsize,\n            precond_step=precond_step,\n        )\n\n    def setup(self, method, precond, prior):\n        self.ivp = load_lotkavolterra()\n        self.stepsize = 1e-2",
        "min_run_count": 2,
        "name": "ivpsolve.IVPSolve.time_solve",
        "number": 0,
        "param_names": [
            "method",
            "precond",
            "prior"
        ],
        "params": [
            [
                "'eks0'",
                "'ekf0'"
            ],
            [
                "'with'",
                "'without'"
            ],
            [
                "'ibm4'",
                "'ioup4'",
                "'matern92'"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "d3933c374498b2fa3db7d34144fb5d3b301b3f2d7700ab6502db1a5eb96f72f1",
        "warmup_time": -1
    },
    "linearsolvers.LinSolve.mem_solve": {
        "code": "class LinSolve:\n    def mem_solve(self, system):\n        # Solve linear system\n        self.xhat, self.Ahat, self.Ainvhat, _ = problinsolve(A=self.A, b=self.b)\n\n    def setup(self, system):\n        # Seed\n        np.random.seed(42)\n    \n        if system == \"sparse\":\n            self.A, self.b = load_poisson_linear_system()\n        elif system == \"dense\":\n            self.A = np.array(\n                [\n                    [2.3, -2.3, 3.5, 4.2, 1.8],\n                    [-2.3, 3.0, -3.5, -4.8, -1.9],\n                    [3.5, -3.5, 6.9, 5.8, 0.8],\n                    [4.2, -4.8, 5.8, 10.1, 6.3],\n                    [1.8, -1.9, 0.8, 6.3, 12.1],\n                ]\n            )\n            self.b = np.random.normal(size=self.A.shape[0])\n        elif system == \"large-scale\":\n            self.A = None\n            self.b = None",
        "name": "linearsolvers.LinSolve.mem_solve",
        "param_names": [
            "system"
        ],
        "params": [
            [
                "'sparse'",
                "'dense'"
            ]
        ],
        "timeout": 60.0,
        "type": "memory",
        "unit": "bytes",
        "version": "bd3605dee3870caa19ac63e742ac002500017ea2c478edbf6cdd5792dfdf482f"
    },
    "linearsolvers.LinSolve.peakmem_solve": {
        "code": "class LinSolve:\n    def peakmem_solve(self, system):\n        # Solve linear system\n        self.xhat, self.Ahat, self.Ainvhat, _ = problinsolve(A=self.A, b=self.b)\n\n    def setup(self, system):\n        # Seed\n        np.random.seed(42)\n    \n        if system == \"sparse\":\n            self.A, self.b = load_poisson_linear_system()\n        elif system == \"dense\":\n            self.A = np.array(\n                [\n                    [2.3, -2.3, 3.5, 4.2, 1.8],\n                    [-2.3, 3.0, -3.5, -4.8, -1.9],\n                    [3.5, -3.5, 6.9, 5.8, 0.8],\n                    [4.2, -4.8, 5.8, 10.1, 6.3],\n                    [1.8, -1.9, 0.8, 6.3, 12.1],\n                ]\n            )\n            self.b = np.random.normal(size=self.A.shape[0])\n        elif system == \"large-scale\":\n            self.A = None\n            self.b = None",
        "name": "linearsolvers.LinSolve.peakmem_solve",
        "param_names": [
            "system"
        ],
        "params": [
            [
                "'sparse'",
                "'dense'"
            ]
        ],
        "timeout": 60.0,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "7b4d2371ef9ae3e9a4e3001899579aa6b1e8b0db9c67458637a0d730ef5f1c7e"
    },
    "linearsolvers.LinSolve.time_solve": {
        "code": "class LinSolve:\n    def time_solve(self, system):\n        # Solve linear system\n        self.xhat, self.Ahat, self.Ainvhat, _ = problinsolve(A=self.A, b=self.b)\n\n    def setup(self, system):\n        # Seed\n        np.random.seed(42)\n    \n        if system == \"sparse\":\n            self.A, self.b = load_poisson_linear_system()\n        elif system == \"dense\":\n            self.A = np.array(\n                [\n                    [2.3, -2.3, 3.5, 4.2, 1.8],\n                    [-2.3, 3.0, -3.5, -4.8, -1.9],\n                    [3.5, -3.5, 6.9, 5.8, 0.8],\n                    [4.2, -4.8, 5.8, 10.1, 6.3],\n                    [1.8, -1.9, 0.8, 6.3, 12.1],\n                ]\n            )\n            self.b = np.random.normal(size=self.A.shape[0])\n        elif system == \"large-scale\":\n            self.A = None\n            self.b = None",
        "min_run_count": 2,
        "name": "linearsolvers.LinSolve.time_solve",
        "number": 0,
        "param_names": [
            "system"
        ],
        "params": [
            [
                "'sparse'",
                "'dense'"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "41949191d688c48fe1f964ab000a79b84251ff048efe0f1064f5c33ff526623b",
        "warmup_time": -1
    },
    "linearsolvers.PosteriorDist.time_sample": {
        "code": "class PosteriorDist:\n    def time_sample(self, output):\n        if output == \"solution\":\n            self.xhat.sample(self.n_samples)\n        elif output == \"matrix\":\n            self.Ahat.sample(self.n_samples)\n        elif output == \"matrix_inverse\":\n            self.Ainvhat.sample(self.n_samples)\n\n    def setup(self, output):\n        # Sparse system\n        self.A, self.b = load_poisson_linear_system()\n    \n        # Solve linear system\n        self.xhat, self.Ahat, self.Ainvhat, _ = problinsolve(A=self.A, b=self.b)\n    \n        # Benchmark parameters\n        self.n_samples = 10",
        "min_run_count": 2,
        "name": "linearsolvers.PosteriorDist.time_sample",
        "number": 0,
        "param_names": [
            "output"
        ],
        "params": [
            [
                "'solution'",
                "'matrix'",
                "'matrix_inverse'"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "e140297042a5ac6c236f00da17a4cb3660a63433fcab0c2f619ef7a57ddfb3d8",
        "warmup_time": -1
    },
    "version": 2
}