{
    "ivpsolve.IVPSolve.peakmem_solve": {
        "code": "class IVPSolve:\n    def peakmem_solve(self, method, precond, prior):\n        # pylint: disable=missing-function-docstring\n        precond_step = self.stepsize if precond == \"with\" else 1.0\n        probsolve_ivp(\n            self.ivp,\n            method=method,\n            which_prior=prior,\n            step=self.stepsize,\n            precond_step=precond_step,\n        )\n\n    def setup(self, method, precond, prior):\n        # pylint: disable=attribute-defined-outside-init,invalid-name,unused-argument\n        self.ivp = load_lotkavolterra()\n        self.stepsize = 1e-2",
        "name": "ivpsolve.IVPSolve.peakmem_solve",
        "param_names": [
            "method",
            "precond",
            "prior"
        ],
        "params": [
            [
                "'eks0'",
                "'ekf0'"
            ],
            [
                "'with'",
                "'without'"
            ],
            [
                "'ibm4'",
                "'ioup4'",
                "'matern92'"
            ]
        ],
        "timeout": 60.0,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "6acb6c24d8cad336d2ffe14263f0235423c2f55075e448fe30a9eb06e1a39f71"
    },
    "ivpsolve.IVPSolve.time_solve": {
        "code": "class IVPSolve:\n    def time_solve(self, method, precond, prior):\n        # pylint: disable=missing-function-docstring\n        precond_step = self.stepsize if precond == \"with\" else 1.0\n        probsolve_ivp(\n            self.ivp,\n            method=method,\n            which_prior=prior,\n            step=self.stepsize,\n            precond_step=precond_step,\n        )\n\n    def setup(self, method, precond, prior):\n        # pylint: disable=attribute-defined-outside-init,invalid-name,unused-argument\n        self.ivp = load_lotkavolterra()\n        self.stepsize = 1e-2",
        "min_run_count": 2,
        "name": "ivpsolve.IVPSolve.time_solve",
        "number": 0,
        "param_names": [
            "method",
            "precond",
            "prior"
        ],
        "params": [
            [
                "'eks0'",
                "'ekf0'"
            ],
            [
                "'with'",
                "'without'"
            ],
            [
                "'ibm4'",
                "'ioup4'",
                "'matern92'"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "ac6ee8a1746a7e6b9f71bd5f6b4b23e9e5bac15b9e60644727688a9bbf429c5f",
        "warmup_time": -1
    },
    "linearsolvers.LinSolve.mem_solve": {
        "code": "class LinSolve:\n    def mem_solve(self, system):\n        \"\"\"Time solving a linear system.\"\"\"\n        # pylint: disable=unused-argument\n        problinsolve(A=self.A, b=self.b)\n\n    def setup(self, system):\n        # pylint: disable=attribute-defined-outside-init,invalid-name\n    \n        # Seed\n        np.random.seed(42)\n    \n        if system == \"sparse\":\n            (\n                self.A,\n                self.b,\n            ) = load_poisson_linear_system()\n        elif system == \"dense\":\n            self.A = SPD_MATRIX_5x5\n            self.b = np.random.normal(size=self.A.shape[0])\n        elif system == \"large-scale\":\n            self.A = None\n            self.b = None",
        "name": "linearsolvers.LinSolve.mem_solve",
        "param_names": [
            "system"
        ],
        "params": [
            [
                "'sparse'",
                "'dense'"
            ]
        ],
        "timeout": 60.0,
        "type": "memory",
        "unit": "bytes",
        "version": "becdada8b3717f565511fbccb86ceaac2e6a58291377b20018c88269cdbe5885"
    },
    "linearsolvers.LinSolve.peakmem_solve": {
        "code": "class LinSolve:\n    def peakmem_solve(self, system):\n        \"\"\"Time solving a linear system.\"\"\"\n        # pylint: disable=unused-argument\n        problinsolve(A=self.A, b=self.b)\n\n    def setup(self, system):\n        # pylint: disable=attribute-defined-outside-init,invalid-name\n    \n        # Seed\n        np.random.seed(42)\n    \n        if system == \"sparse\":\n            (\n                self.A,\n                self.b,\n            ) = load_poisson_linear_system()\n        elif system == \"dense\":\n            self.A = SPD_MATRIX_5x5\n            self.b = np.random.normal(size=self.A.shape[0])\n        elif system == \"large-scale\":\n            self.A = None\n            self.b = None",
        "name": "linearsolvers.LinSolve.peakmem_solve",
        "param_names": [
            "system"
        ],
        "params": [
            [
                "'sparse'",
                "'dense'"
            ]
        ],
        "timeout": 60.0,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "ed10b70bcc839fcfd1520c3f457ec95f984fb64fb994c99357ac98dfb0c52ebc"
    },
    "linearsolvers.LinSolve.time_solve": {
        "code": "class LinSolve:\n    def time_solve(self, system):\n        \"\"\"Time solving a linear system.\"\"\"\n        # pylint: disable=unused-argument\n        problinsolve(A=self.A, b=self.b)\n\n    def setup(self, system):\n        # pylint: disable=attribute-defined-outside-init,invalid-name\n    \n        # Seed\n        np.random.seed(42)\n    \n        if system == \"sparse\":\n            (\n                self.A,\n                self.b,\n            ) = load_poisson_linear_system()\n        elif system == \"dense\":\n            self.A = SPD_MATRIX_5x5\n            self.b = np.random.normal(size=self.A.shape[0])\n        elif system == \"large-scale\":\n            self.A = None\n            self.b = None",
        "min_run_count": 2,
        "name": "linearsolvers.LinSolve.time_solve",
        "number": 0,
        "param_names": [
            "system"
        ],
        "params": [
            [
                "'sparse'",
                "'dense'"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "d0ce131654f8bcfc9222617222f13a7f33160a1a258e5676287104b4f8dac8b1",
        "warmup_time": -1
    },
    "linearsolvers.PosteriorDist.time_sample": {
        "code": "class PosteriorDist:\n    def time_sample(self, output):\n        \"\"\"Time sampling from the posterior distribution.\"\"\"\n        if output == \"solution\":\n            self.xhat.sample(self.n_samples)\n        elif output == \"matrix\":\n            self.Ahat.sample(self.n_samples)\n        elif output == \"matrix_inverse\":\n            self.Ainvhat.sample(self.n_samples)\n\n    def setup(self, output):\n        # pylint: disable=attribute-defined-outside-init\n        # pylint: disable=unused-argument, invalid-name\n    \n        # Sparse system\n        self.A, self.b = load_poisson_linear_system()\n    \n        # Solve linear system\n        self.xhat, self.Ahat, self.Ainvhat, _ = problinsolve(A=self.A, b=self.b)\n    \n        # Benchmark parameters\n        self.n_samples = 10",
        "min_run_count": 2,
        "name": "linearsolvers.PosteriorDist.time_sample",
        "number": 0,
        "param_names": [
            "output"
        ],
        "params": [
            [
                "'solution'",
                "'matrix'",
                "'matrix_inverse'"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "7d57eec1c4c5c33913b7ac58cbcce0140d4f4f58ce13ac5f8d6801d4dc895c27",
        "warmup_time": -1
    },
    "random_variables.Functions.time_distr_functions": {
        "code": "class Functions:\n    def time_distr_functions(self, randvar, method):\n        \"\"\"Times evaluation of the pdf, logpdf, cdf and logcdf.\"\"\"\n        # pylint: disable=unused-argument\n    \n        try:\n            if method == \"pdf\":\n                self.randvar.pdf(x=self.eval_point)\n            elif method == \"logpdf\":\n                self.randvar.logpdf(x=self.eval_point)\n            elif method == \"cdf\":\n                self.randvar.cdf(x=self.quantile)\n            elif method == \"logcdf\":\n                self.randvar.logcdf(x=self.quantile)\n        except NotImplementedError:\n            pass\n\n    def setup(self, randvar, method):\n        # pylint: disable=unused-argument,attribute-defined-outside-init,missing-function-docstring\n    \n        self.randvar = get_randvar(rv_name=randvar)\n        self.eval_point = np.random.uniform(size=self.randvar.shape)\n        self.quantile = np.random.uniform(size=self.randvar.shape)",
        "min_run_count": 2,
        "name": "random_variables.Functions.time_distr_functions",
        "number": 0,
        "param_names": [
            "randvar",
            "method"
        ],
        "params": [
            [
                "'univar_normal'",
                "'multivar_normal'",
                "'matrixvar_normal'",
                "'symmatrixvar_normal'",
                "'operatorvar_normal'"
            ],
            [
                "'pdf'",
                "'logpdf'",
                "'cdf'",
                "'logcdf'"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "39047fa2bb91231e61263c8f810d548393fe9968732698178b6e9787f28a03ff",
        "warmup_time": -1
    },
    "random_variables.Sampling.peakmem_sample": {
        "code": "class Sampling:\n    def peakmem_sample(self, randvar):\n        \"\"\"Peak memory of sampling process.\"\"\"\n        # pylint: disable=unused-argument\n    \n        self.randvar.sample(self.n_samples)\n\n    def setup(self, randvar):\n        # pylint: disable=unused-argument,attribute-defined-outside-init,missing-function-docstring\n        np.random.seed(42)\n        self.n_samples = 1000\n        self.randvar = get_randvar(rv_name=randvar)",
        "name": "random_variables.Sampling.peakmem_sample",
        "param_names": [
            "randvar"
        ],
        "params": [
            [
                "'univar_normal'",
                "'multivar_normal'",
                "'matrixvar_normal'",
                "'symmatrixvar_normal'",
                "'operatorvar_normal'"
            ]
        ],
        "timeout": 60.0,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "dac6781498b5731f02dbad304bba26eeae832660510a0d07e435e9d9d36b63fd"
    },
    "random_variables.Sampling.time_sample": {
        "code": "class Sampling:\n    def time_sample(self, randvar):\n        \"\"\"Times sampling from this distribution.\"\"\"\n        # pylint: disable=unused-argument\n    \n        self.randvar.sample(self.n_samples)\n\n    def setup(self, randvar):\n        # pylint: disable=unused-argument,attribute-defined-outside-init,missing-function-docstring\n        np.random.seed(42)\n        self.n_samples = 1000\n        self.randvar = get_randvar(rv_name=randvar)",
        "min_run_count": 2,
        "name": "random_variables.Sampling.time_sample",
        "number": 0,
        "param_names": [
            "randvar"
        ],
        "params": [
            [
                "'univar_normal'",
                "'multivar_normal'",
                "'matrixvar_normal'",
                "'symmatrixvar_normal'",
                "'operatorvar_normal'"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "77b92dae35ae884b2672c8fe7fbe9d8d9ede2172f682abf8007f504a3dbce2f2",
        "warmup_time": -1
    },
    "version": 2
}