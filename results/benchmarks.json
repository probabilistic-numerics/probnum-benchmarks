{
    "filtsmooth.DenseGridOperations.peakmem_dense_filter": {
        "code": "class DenseGridOperations:\n    def peakmem_dense_filter(self, linearization_implementation, num_samples):\n        self.filtering_posterior(self.dense_locations)\n\n    def setup(self, linearization_implementation, num_samples):\n        measvar = 0.1024\n        initrv = randvars.Normal(np.ones(2), measvar * np.eye(2))\n        rng = np.random.default_rng(seed=1)\n        regression_problem, info = filtsmooth_zoo.pendulum(\n            rng=rng,\n            measurement_variance=measvar,\n            timespan=(0.0, 4.0),\n            step=0.0075,\n            initrv=initrv,\n        )\n        prior_process = info[\"prior_process\"]\n    \n        linearization, implementation = linearization_implementation\n        _lin_method = {\n            \"ekf\": functools.partial(\n                filtsmooth.gaussian.approx.DiscreteEKFComponent,\n                forward_implementation=implementation,\n                backward_implementation=implementation,\n            ),\n            \"ukf\": filtsmooth.gaussian.approx.DiscreteUKFComponent,\n        }[linearization]\n    \n        self.dense_locations = np.sort(\n            np.unique(\n                np.random.uniform(\n                    low=regression_problem.locations[0],\n                    high=1.2 * regression_problem.locations[-1],\n                    size=int(1.2 * len(regression_problem.locations)),\n                )\n            )\n        )\n    \n        linearized_dynmod = _lin_method(prior_process.transition)\n        linearized_measmod = _lin_method(regression_problem.measurement_models[0])\n        regression_problem.measurement_models = [linearized_measmod] * len(\n            regression_problem.locations\n        )\n    \n        prior_process = randprocs.markov.MarkovProcess(\n            transition=linearized_dynmod,\n            initrv=prior_process.initrv,\n            initarg=regression_problem.locations[0],\n        )\n    \n        self.kalman_filter = filtsmooth.gaussian.Kalman(prior_process=prior_process)\n    \n        self.filtering_posterior, _ = self.kalman_filter.filter(regression_problem)\n        self.smoothing_posterior = self.kalman_filter.smooth(\n            filter_posterior=self.filtering_posterior\n        )",
        "name": "filtsmooth.DenseGridOperations.peakmem_dense_filter",
        "param_names": [
            "linearization_implementation",
            "num_samples"
        ],
        "params": [
            [
                "('ekf', 'classic')",
                "('ekf', 'sqrt')",
                "('ukf', 'classic')"
            ],
            [
                "1",
                "10"
            ]
        ],
        "timeout": 60.0,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "04c24e9957138713fff0c0785f2ebe9453287cbb3a071fa7ec5d2a9cb13edafe"
    },
    "filtsmooth.DenseGridOperations.peakmem_dense_smoother": {
        "code": "class DenseGridOperations:\n    def peakmem_dense_smoother(self, linearization_implementation, num_samples):\n        self.smoothing_posterior(self.dense_locations)\n\n    def setup(self, linearization_implementation, num_samples):\n        measvar = 0.1024\n        initrv = randvars.Normal(np.ones(2), measvar * np.eye(2))\n        rng = np.random.default_rng(seed=1)\n        regression_problem, info = filtsmooth_zoo.pendulum(\n            rng=rng,\n            measurement_variance=measvar,\n            timespan=(0.0, 4.0),\n            step=0.0075,\n            initrv=initrv,\n        )\n        prior_process = info[\"prior_process\"]\n    \n        linearization, implementation = linearization_implementation\n        _lin_method = {\n            \"ekf\": functools.partial(\n                filtsmooth.gaussian.approx.DiscreteEKFComponent,\n                forward_implementation=implementation,\n                backward_implementation=implementation,\n            ),\n            \"ukf\": filtsmooth.gaussian.approx.DiscreteUKFComponent,\n        }[linearization]\n    \n        self.dense_locations = np.sort(\n            np.unique(\n                np.random.uniform(\n                    low=regression_problem.locations[0],\n                    high=1.2 * regression_problem.locations[-1],\n                    size=int(1.2 * len(regression_problem.locations)),\n                )\n            )\n        )\n    \n        linearized_dynmod = _lin_method(prior_process.transition)\n        linearized_measmod = _lin_method(regression_problem.measurement_models[0])\n        regression_problem.measurement_models = [linearized_measmod] * len(\n            regression_problem.locations\n        )\n    \n        prior_process = randprocs.markov.MarkovProcess(\n            transition=linearized_dynmod,\n            initrv=prior_process.initrv,\n            initarg=regression_problem.locations[0],\n        )\n    \n        self.kalman_filter = filtsmooth.gaussian.Kalman(prior_process=prior_process)\n    \n        self.filtering_posterior, _ = self.kalman_filter.filter(regression_problem)\n        self.smoothing_posterior = self.kalman_filter.smooth(\n            filter_posterior=self.filtering_posterior\n        )",
        "name": "filtsmooth.DenseGridOperations.peakmem_dense_smoother",
        "param_names": [
            "linearization_implementation",
            "num_samples"
        ],
        "params": [
            [
                "('ekf', 'classic')",
                "('ekf', 'sqrt')",
                "('ukf', 'classic')"
            ],
            [
                "1",
                "10"
            ]
        ],
        "timeout": 60.0,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "06717c47a9c1eb5b5099cc393bce8ca7cf6b91b4b2fb94dce9c0548ef5b5422c"
    },
    "filtsmooth.DenseGridOperations.peakmem_sample": {
        "code": "class DenseGridOperations:\n    def peakmem_sample(self, linearization_implementation, num_samples):\n        rng = np.random.default_rng(seed=1)\n        self.smoothing_posterior.sample(\n            rng=rng, t=self.dense_locations, size=num_samples\n        )\n\n    def setup(self, linearization_implementation, num_samples):\n        measvar = 0.1024\n        initrv = randvars.Normal(np.ones(2), measvar * np.eye(2))\n        rng = np.random.default_rng(seed=1)\n        regression_problem, info = filtsmooth_zoo.pendulum(\n            rng=rng,\n            measurement_variance=measvar,\n            timespan=(0.0, 4.0),\n            step=0.0075,\n            initrv=initrv,\n        )\n        prior_process = info[\"prior_process\"]\n    \n        linearization, implementation = linearization_implementation\n        _lin_method = {\n            \"ekf\": functools.partial(\n                filtsmooth.gaussian.approx.DiscreteEKFComponent,\n                forward_implementation=implementation,\n                backward_implementation=implementation,\n            ),\n            \"ukf\": filtsmooth.gaussian.approx.DiscreteUKFComponent,\n        }[linearization]\n    \n        self.dense_locations = np.sort(\n            np.unique(\n                np.random.uniform(\n                    low=regression_problem.locations[0],\n                    high=1.2 * regression_problem.locations[-1],\n                    size=int(1.2 * len(regression_problem.locations)),\n                )\n            )\n        )\n    \n        linearized_dynmod = _lin_method(prior_process.transition)\n        linearized_measmod = _lin_method(regression_problem.measurement_models[0])\n        regression_problem.measurement_models = [linearized_measmod] * len(\n            regression_problem.locations\n        )\n    \n        prior_process = randprocs.markov.MarkovProcess(\n            transition=linearized_dynmod,\n            initrv=prior_process.initrv,\n            initarg=regression_problem.locations[0],\n        )\n    \n        self.kalman_filter = filtsmooth.gaussian.Kalman(prior_process=prior_process)\n    \n        self.filtering_posterior, _ = self.kalman_filter.filter(regression_problem)\n        self.smoothing_posterior = self.kalman_filter.smooth(\n            filter_posterior=self.filtering_posterior\n        )",
        "name": "filtsmooth.DenseGridOperations.peakmem_sample",
        "param_names": [
            "linearization_implementation",
            "num_samples"
        ],
        "params": [
            [
                "('ekf', 'classic')",
                "('ekf', 'sqrt')",
                "('ukf', 'classic')"
            ],
            [
                "1",
                "10"
            ]
        ],
        "timeout": 60.0,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "40f48e9b607c19e83208d3e321b8244e8b46029694be83d71e2be719bdd4b18d"
    },
    "filtsmooth.DenseGridOperations.time_dense_filter": {
        "code": "class DenseGridOperations:\n    def time_dense_filter(self, linearization_implementation, num_samples):\n        self.filtering_posterior(self.dense_locations)\n\n    def setup(self, linearization_implementation, num_samples):\n        measvar = 0.1024\n        initrv = randvars.Normal(np.ones(2), measvar * np.eye(2))\n        rng = np.random.default_rng(seed=1)\n        regression_problem, info = filtsmooth_zoo.pendulum(\n            rng=rng,\n            measurement_variance=measvar,\n            timespan=(0.0, 4.0),\n            step=0.0075,\n            initrv=initrv,\n        )\n        prior_process = info[\"prior_process\"]\n    \n        linearization, implementation = linearization_implementation\n        _lin_method = {\n            \"ekf\": functools.partial(\n                filtsmooth.gaussian.approx.DiscreteEKFComponent,\n                forward_implementation=implementation,\n                backward_implementation=implementation,\n            ),\n            \"ukf\": filtsmooth.gaussian.approx.DiscreteUKFComponent,\n        }[linearization]\n    \n        self.dense_locations = np.sort(\n            np.unique(\n                np.random.uniform(\n                    low=regression_problem.locations[0],\n                    high=1.2 * regression_problem.locations[-1],\n                    size=int(1.2 * len(regression_problem.locations)),\n                )\n            )\n        )\n    \n        linearized_dynmod = _lin_method(prior_process.transition)\n        linearized_measmod = _lin_method(regression_problem.measurement_models[0])\n        regression_problem.measurement_models = [linearized_measmod] * len(\n            regression_problem.locations\n        )\n    \n        prior_process = randprocs.markov.MarkovProcess(\n            transition=linearized_dynmod,\n            initrv=prior_process.initrv,\n            initarg=regression_problem.locations[0],\n        )\n    \n        self.kalman_filter = filtsmooth.gaussian.Kalman(prior_process=prior_process)\n    \n        self.filtering_posterior, _ = self.kalman_filter.filter(regression_problem)\n        self.smoothing_posterior = self.kalman_filter.smooth(\n            filter_posterior=self.filtering_posterior\n        )",
        "min_run_count": 2,
        "name": "filtsmooth.DenseGridOperations.time_dense_filter",
        "number": 0,
        "param_names": [
            "linearization_implementation",
            "num_samples"
        ],
        "params": [
            [
                "('ekf', 'classic')",
                "('ekf', 'sqrt')",
                "('ukf', 'classic')"
            ],
            [
                "1",
                "10"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "69cb869d04c8a1558fad0aa3dffb778570cea2a4e94d32989f8c15a4a9be57b2",
        "warmup_time": -1
    },
    "filtsmooth.DenseGridOperations.time_dense_smoother": {
        "code": "class DenseGridOperations:\n    def time_dense_smoother(self, linearization_implementation, num_samples):\n        self.smoothing_posterior(self.dense_locations)\n\n    def setup(self, linearization_implementation, num_samples):\n        measvar = 0.1024\n        initrv = randvars.Normal(np.ones(2), measvar * np.eye(2))\n        rng = np.random.default_rng(seed=1)\n        regression_problem, info = filtsmooth_zoo.pendulum(\n            rng=rng,\n            measurement_variance=measvar,\n            timespan=(0.0, 4.0),\n            step=0.0075,\n            initrv=initrv,\n        )\n        prior_process = info[\"prior_process\"]\n    \n        linearization, implementation = linearization_implementation\n        _lin_method = {\n            \"ekf\": functools.partial(\n                filtsmooth.gaussian.approx.DiscreteEKFComponent,\n                forward_implementation=implementation,\n                backward_implementation=implementation,\n            ),\n            \"ukf\": filtsmooth.gaussian.approx.DiscreteUKFComponent,\n        }[linearization]\n    \n        self.dense_locations = np.sort(\n            np.unique(\n                np.random.uniform(\n                    low=regression_problem.locations[0],\n                    high=1.2 * regression_problem.locations[-1],\n                    size=int(1.2 * len(regression_problem.locations)),\n                )\n            )\n        )\n    \n        linearized_dynmod = _lin_method(prior_process.transition)\n        linearized_measmod = _lin_method(regression_problem.measurement_models[0])\n        regression_problem.measurement_models = [linearized_measmod] * len(\n            regression_problem.locations\n        )\n    \n        prior_process = randprocs.markov.MarkovProcess(\n            transition=linearized_dynmod,\n            initrv=prior_process.initrv,\n            initarg=regression_problem.locations[0],\n        )\n    \n        self.kalman_filter = filtsmooth.gaussian.Kalman(prior_process=prior_process)\n    \n        self.filtering_posterior, _ = self.kalman_filter.filter(regression_problem)\n        self.smoothing_posterior = self.kalman_filter.smooth(\n            filter_posterior=self.filtering_posterior\n        )",
        "min_run_count": 2,
        "name": "filtsmooth.DenseGridOperations.time_dense_smoother",
        "number": 0,
        "param_names": [
            "linearization_implementation",
            "num_samples"
        ],
        "params": [
            [
                "('ekf', 'classic')",
                "('ekf', 'sqrt')",
                "('ukf', 'classic')"
            ],
            [
                "1",
                "10"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "edbf81162b7a27d98f83ca8ef7813b9134439353c8ab7d9aef584a2b0af6e9f0",
        "warmup_time": -1
    },
    "filtsmooth.DenseGridOperations.time_sample": {
        "code": "class DenseGridOperations:\n    def time_sample(self, linearization_implementation, num_samples):\n        rng = np.random.default_rng(seed=1)\n        self.smoothing_posterior.sample(\n            rng=rng, t=self.dense_locations, size=num_samples\n        )\n\n    def setup(self, linearization_implementation, num_samples):\n        measvar = 0.1024\n        initrv = randvars.Normal(np.ones(2), measvar * np.eye(2))\n        rng = np.random.default_rng(seed=1)\n        regression_problem, info = filtsmooth_zoo.pendulum(\n            rng=rng,\n            measurement_variance=measvar,\n            timespan=(0.0, 4.0),\n            step=0.0075,\n            initrv=initrv,\n        )\n        prior_process = info[\"prior_process\"]\n    \n        linearization, implementation = linearization_implementation\n        _lin_method = {\n            \"ekf\": functools.partial(\n                filtsmooth.gaussian.approx.DiscreteEKFComponent,\n                forward_implementation=implementation,\n                backward_implementation=implementation,\n            ),\n            \"ukf\": filtsmooth.gaussian.approx.DiscreteUKFComponent,\n        }[linearization]\n    \n        self.dense_locations = np.sort(\n            np.unique(\n                np.random.uniform(\n                    low=regression_problem.locations[0],\n                    high=1.2 * regression_problem.locations[-1],\n                    size=int(1.2 * len(regression_problem.locations)),\n                )\n            )\n        )\n    \n        linearized_dynmod = _lin_method(prior_process.transition)\n        linearized_measmod = _lin_method(regression_problem.measurement_models[0])\n        regression_problem.measurement_models = [linearized_measmod] * len(\n            regression_problem.locations\n        )\n    \n        prior_process = randprocs.markov.MarkovProcess(\n            transition=linearized_dynmod,\n            initrv=prior_process.initrv,\n            initarg=regression_problem.locations[0],\n        )\n    \n        self.kalman_filter = filtsmooth.gaussian.Kalman(prior_process=prior_process)\n    \n        self.filtering_posterior, _ = self.kalman_filter.filter(regression_problem)\n        self.smoothing_posterior = self.kalman_filter.smooth(\n            filter_posterior=self.filtering_posterior\n        )",
        "min_run_count": 2,
        "name": "filtsmooth.DenseGridOperations.time_sample",
        "number": 0,
        "param_names": [
            "linearization_implementation",
            "num_samples"
        ],
        "params": [
            [
                "('ekf', 'classic')",
                "('ekf', 'sqrt')",
                "('ukf', 'classic')"
            ],
            [
                "1",
                "10"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "7b414311f5640ce62678ee97c5113bf406b51509d72ffe8fb82d3c054dc87fd5",
        "warmup_time": -1
    },
    "filtsmooth.Filtering.peakmem_filter": {
        "code": "class Filtering:\n    def peakmem_filter(self, linearization_implementation):\n        self.kalman_filter.filter(self.regression_problem)\n\n    def setup(self, linearization_implementation):\n        measvar = 0.1024\n        initrv = randvars.Normal(np.ones(2), measvar * np.eye(2))\n        rng = np.random.default_rng(seed=1)\n        regression_problem, info = filtsmooth_zoo.pendulum(\n            rng=rng,\n            measurement_variance=measvar,\n            timespan=(0.0, 4.0),\n            step=0.0075,\n            initrv=initrv,\n        )\n        prior_process = info[\"prior_process\"]\n    \n        linearization, implementation = linearization_implementation\n        _lin_method = {\n            \"ekf\": functools.partial(\n                filtsmooth.gaussian.approx.DiscreteEKFComponent,\n                forward_implementation=implementation,\n                backward_implementation=implementation,\n            ),\n            \"ukf\": filtsmooth.gaussian.approx.DiscreteUKFComponent,\n        }[linearization]\n    \n        linearized_dynmod = _lin_method(prior_process.transition)\n        linearized_measmod = _lin_method(regression_problem.measurement_models[0])\n        regression_problem.measurement_models = [linearized_measmod] * len(\n            regression_problem.locations\n        )\n    \n        prior_process = randprocs.markov.MarkovProcess(\n            transition=linearized_dynmod,\n            initrv=prior_process.initrv,\n            initarg=regression_problem.locations[0],\n        )\n        self.regression_problem = regression_problem\n    \n        self.kalman_filter = filtsmooth.gaussian.Kalman(prior_process=prior_process)",
        "name": "filtsmooth.Filtering.peakmem_filter",
        "param_names": [
            "linearization_implementation"
        ],
        "params": [
            [
                "('ekf', 'classic')",
                "('ekf', 'sqrt')",
                "('ukf', 'classic')"
            ]
        ],
        "timeout": 60.0,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "f86393f33a5e3bb65abe382abc43d9233b806945e94738e0539e6813078db37f"
    },
    "filtsmooth.Filtering.time_filter": {
        "code": "class Filtering:\n    def time_filter(self, linearization_implementation):\n        self.kalman_filter.filter(self.regression_problem)\n\n    def setup(self, linearization_implementation):\n        measvar = 0.1024\n        initrv = randvars.Normal(np.ones(2), measvar * np.eye(2))\n        rng = np.random.default_rng(seed=1)\n        regression_problem, info = filtsmooth_zoo.pendulum(\n            rng=rng,\n            measurement_variance=measvar,\n            timespan=(0.0, 4.0),\n            step=0.0075,\n            initrv=initrv,\n        )\n        prior_process = info[\"prior_process\"]\n    \n        linearization, implementation = linearization_implementation\n        _lin_method = {\n            \"ekf\": functools.partial(\n                filtsmooth.gaussian.approx.DiscreteEKFComponent,\n                forward_implementation=implementation,\n                backward_implementation=implementation,\n            ),\n            \"ukf\": filtsmooth.gaussian.approx.DiscreteUKFComponent,\n        }[linearization]\n    \n        linearized_dynmod = _lin_method(prior_process.transition)\n        linearized_measmod = _lin_method(regression_problem.measurement_models[0])\n        regression_problem.measurement_models = [linearized_measmod] * len(\n            regression_problem.locations\n        )\n    \n        prior_process = randprocs.markov.MarkovProcess(\n            transition=linearized_dynmod,\n            initrv=prior_process.initrv,\n            initarg=regression_problem.locations[0],\n        )\n        self.regression_problem = regression_problem\n    \n        self.kalman_filter = filtsmooth.gaussian.Kalman(prior_process=prior_process)",
        "min_run_count": 2,
        "name": "filtsmooth.Filtering.time_filter",
        "number": 0,
        "param_names": [
            "linearization_implementation"
        ],
        "params": [
            [
                "('ekf', 'classic')",
                "('ekf', 'sqrt')",
                "('ukf', 'classic')"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "f14e6fc2893b0fe4037c8a7ed6fa090c3986966035331c0ad795bf26d20538fd",
        "warmup_time": -1
    },
    "filtsmooth.Smoothing.peakmem_smooth": {
        "code": "class Smoothing:\n    def peakmem_smooth(self, linearization_implementation):\n        self.kalman_filter.smooth(filter_posterior=self.filtering_posterior)\n\n    def setup(self, linearization_implementation):\n        measvar = 0.1024\n        initrv = randvars.Normal(np.ones(2), measvar * np.eye(2))\n        rng = np.random.default_rng(seed=1)\n        regression_problem, info = filtsmooth_zoo.pendulum(\n            rng=rng,\n            measurement_variance=measvar,\n            timespan=(0.0, 4.0),\n            step=0.0075,\n            initrv=initrv,\n        )\n        prior_process = info[\"prior_process\"]\n    \n        linearization, implementation = linearization_implementation\n        _lin_method = {\n            \"ekf\": functools.partial(\n                filtsmooth.gaussian.approx.DiscreteEKFComponent,\n                forward_implementation=implementation,\n                backward_implementation=implementation,\n            ),\n            \"ukf\": filtsmooth.gaussian.approx.DiscreteUKFComponent,\n        }[linearization]\n    \n        linearized_dynmod = _lin_method(prior_process.transition)\n        linearized_measmod = _lin_method(regression_problem.measurement_models[0])\n        regression_problem.measurement_models = [linearized_measmod] * len(\n            regression_problem.locations\n        )\n    \n        prior_process = randprocs.markov.MarkovProcess(\n            transition=linearized_dynmod,\n            initrv=prior_process.initrv,\n            initarg=regression_problem.locations[0],\n        )\n    \n        self.kalman_filter = filtsmooth.gaussian.Kalman(prior_process=prior_process)\n        self.filtering_posterior, _ = self.kalman_filter.filter(regression_problem)",
        "name": "filtsmooth.Smoothing.peakmem_smooth",
        "param_names": [
            "linearization_implementation"
        ],
        "params": [
            [
                "('ekf', 'classic')",
                "('ekf', 'sqrt')",
                "('ukf', 'classic')"
            ]
        ],
        "timeout": 60.0,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "fe78fa9fda2f4949e71676826c8344780b279b0f3f44162c3a5bb67445890959"
    },
    "filtsmooth.Smoothing.time_smooth": {
        "code": "class Smoothing:\n    def time_smooth(self, linearization_implementation):\n        self.kalman_filter.smooth(filter_posterior=self.filtering_posterior)\n\n    def setup(self, linearization_implementation):\n        measvar = 0.1024\n        initrv = randvars.Normal(np.ones(2), measvar * np.eye(2))\n        rng = np.random.default_rng(seed=1)\n        regression_problem, info = filtsmooth_zoo.pendulum(\n            rng=rng,\n            measurement_variance=measvar,\n            timespan=(0.0, 4.0),\n            step=0.0075,\n            initrv=initrv,\n        )\n        prior_process = info[\"prior_process\"]\n    \n        linearization, implementation = linearization_implementation\n        _lin_method = {\n            \"ekf\": functools.partial(\n                filtsmooth.gaussian.approx.DiscreteEKFComponent,\n                forward_implementation=implementation,\n                backward_implementation=implementation,\n            ),\n            \"ukf\": filtsmooth.gaussian.approx.DiscreteUKFComponent,\n        }[linearization]\n    \n        linearized_dynmod = _lin_method(prior_process.transition)\n        linearized_measmod = _lin_method(regression_problem.measurement_models[0])\n        regression_problem.measurement_models = [linearized_measmod] * len(\n            regression_problem.locations\n        )\n    \n        prior_process = randprocs.markov.MarkovProcess(\n            transition=linearized_dynmod,\n            initrv=prior_process.initrv,\n            initarg=regression_problem.locations[0],\n        )\n    \n        self.kalman_filter = filtsmooth.gaussian.Kalman(prior_process=prior_process)\n        self.filtering_posterior, _ = self.kalman_filter.filter(regression_problem)",
        "min_run_count": 2,
        "name": "filtsmooth.Smoothing.time_smooth",
        "number": 0,
        "param_names": [
            "linearization_implementation"
        ],
        "params": [
            [
                "('ekf', 'classic')",
                "('ekf', 'sqrt')",
                "('ukf', 'classic')"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "f9ff2b4ce736cd8f88385c8e741dd5945de558f0b643940bfff0642324d5f92c",
        "warmup_time": -1
    },
    "ivpsolvers.IVPSolve.peakmem_solve": {
        "code": "class IVPSolve:\n    def peakmem_solve(self, method, algo_order):\n        probsolve_ivp(\n            f=self.ivp.f,\n            t0=self.ivp.t0,\n            tmax=self.ivp.tmax,\n            y0=self.ivp.y0,\n            df=self.ivp.df,\n            method=method,\n            dense_output=True,\n            algo_order=algo_order,\n            step=self.stepsize,\n            adaptive=False,\n        )\n\n    def setup(self, method, prior):\n        # pylint: disable=invalid-name\n        self.ivp = load_lotkavolterra()\n        self.stepsize = 1e-1",
        "name": "ivpsolvers.IVPSolve.peakmem_solve",
        "param_names": [
            "method",
            "algo_order"
        ],
        "params": [
            [
                "'ek0'",
                "'ek1'"
            ],
            [
                "2",
                "3"
            ]
        ],
        "timeout": 60.0,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "21081f5f8c9e7649ac7918e029fe7c37750c1bf26033fc019bc8690436ad19eb"
    },
    "ivpsolvers.IVPSolve.time_solve": {
        "code": "class IVPSolve:\n    def time_solve(self, method, algo_order):\n        probsolve_ivp(\n            f=self.ivp.f,\n            t0=self.ivp.t0,\n            tmax=self.ivp.tmax,\n            y0=self.ivp.y0,\n            df=self.ivp.df,\n            method=method,\n            dense_output=True,\n            algo_order=algo_order,\n            step=self.stepsize,\n            adaptive=False,\n        )\n\n    def setup(self, method, prior):\n        # pylint: disable=invalid-name\n        self.ivp = load_lotkavolterra()\n        self.stepsize = 1e-1",
        "min_run_count": 2,
        "name": "ivpsolvers.IVPSolve.time_solve",
        "number": 0,
        "param_names": [
            "method",
            "algo_order"
        ],
        "params": [
            [
                "'ek0'",
                "'ek1'"
            ],
            [
                "2",
                "3"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "a227381cd9f6b606534b487836869be4c236542c5a70590d392d343ded59d977",
        "warmup_time": -1
    },
    "kernels.Kernels.peakmem_kernel_matrix": {
        "code": "class Kernels:\n    def peakmem_kernel_matrix(self, kernel, n_datapoints):\n        \"\"\"Peak memory of sampling process.\"\"\"\n        self.kernel(self.data)\n\n    def setup(self, kernel, n_datapoints):\n        rng = np.random.default_rng(42)\n        self.input_dim = 100\n        self.data = rng.normal(size=(n_datapoints, self.input_dim))\n        self.kernel = get_kernel(kernel_name=kernel, input_dim=self.input_dim)",
        "name": "kernels.Kernels.peakmem_kernel_matrix",
        "param_names": [
            "kernel",
            "n_datapoints"
        ],
        "params": [
            [
                "'white_noise'",
                "'linear'",
                "'polynomial'",
                "'exp_quad'",
                "'rat_quad'",
                "'matern12'",
                "'matern32'",
                "'matern52'",
                "'matern72'"
            ],
            [
                "10",
                "100",
                "1000"
            ]
        ],
        "timeout": 60.0,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "b4f420e1ef1214a865c6f026feb39a43143f57a26b361623fb63418e2f0a01b1"
    },
    "kernels.Kernels.time_kernel_matrix": {
        "code": "class Kernels:\n    def time_kernel_matrix(self, kernel, n_datapoints):\n        \"\"\"Times sampling from this distribution.\"\"\"\n        self.kernel(self.data)\n\n    def setup(self, kernel, n_datapoints):\n        rng = np.random.default_rng(42)\n        self.input_dim = 100\n        self.data = rng.normal(size=(n_datapoints, self.input_dim))\n        self.kernel = get_kernel(kernel_name=kernel, input_dim=self.input_dim)",
        "min_run_count": 2,
        "name": "kernels.Kernels.time_kernel_matrix",
        "number": 0,
        "param_names": [
            "kernel",
            "n_datapoints"
        ],
        "params": [
            [
                "'white_noise'",
                "'linear'",
                "'polynomial'",
                "'exp_quad'",
                "'rat_quad'",
                "'matern12'",
                "'matern32'",
                "'matern52'",
                "'matern72'"
            ],
            [
                "10",
                "100",
                "1000"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "bd80bb62c96bc059c77c591c8a2f9c501cce5fe29dd92efb750ce55f0ada226e",
        "warmup_time": -1
    },
    "linearsolvers.LinSolve.peakmem_solve": {
        "code": "class LinSolve:\n    def peakmem_solve(self, linsys, dim):\n        problinsolve(A=self.linsys.A, b=self.linsys.b)\n\n    def setup(self, linsys, dim):\n        self.linsys = get_linear_system(name=linsys, dim=dim)\n        xhat, _, _, _ = problinsolve(A=self.linsys.A, b=self.linsys.b)\n        self.xhat = xhat",
        "name": "linearsolvers.LinSolve.peakmem_solve",
        "param_names": [
            "linsys",
            "dim"
        ],
        "params": [
            [
                "'dense'",
                "'sparse'",
                "'linop'"
            ],
            [
                "100",
                "1000",
                "10000",
                "100000"
            ]
        ],
        "timeout": 60.0,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "319e4cd5c37e9c2c9c99d62d7ce07de29eccf4bc310801d1b6efac1d45c81d0e"
    },
    "linearsolvers.LinSolve.time_solve": {
        "code": "class LinSolve:\n    def time_solve(self, linsys, dim):\n        problinsolve(A=self.linsys.A, b=self.linsys.b)\n\n    def setup(self, linsys, dim):\n        self.linsys = get_linear_system(name=linsys, dim=dim)\n        xhat, _, _, _ = problinsolve(A=self.linsys.A, b=self.linsys.b)\n        self.xhat = xhat",
        "min_run_count": 2,
        "name": "linearsolvers.LinSolve.time_solve",
        "number": 0,
        "param_names": [
            "linsys",
            "dim"
        ],
        "params": [
            [
                "'dense'",
                "'sparse'",
                "'linop'"
            ],
            [
                "100",
                "1000",
                "10000",
                "100000"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "5d87248d348027d440cc249ddc3fc11d54b0ff028f4bca3dc6f17ba6533a7f84",
        "warmup_time": -1
    },
    "linearsolvers.LinSolve.track_error_2norm": {
        "code": "class LinSolve:\n    def track_error_2norm(self, linsys, dim):\n        return np.linalg.norm(self.linsys.solution - self.xhat.mean)\n\n    def setup(self, linsys, dim):\n        self.linsys = get_linear_system(name=linsys, dim=dim)\n        xhat, _, _, _ = problinsolve(A=self.linsys.A, b=self.linsys.b)\n        self.xhat = xhat",
        "name": "linearsolvers.LinSolve.track_error_2norm",
        "param_names": [
            "linsys",
            "dim"
        ],
        "params": [
            [
                "'dense'",
                "'sparse'",
                "'linop'"
            ],
            [
                "100",
                "1000",
                "10000",
                "100000"
            ]
        ],
        "timeout": 60.0,
        "type": "track",
        "unit": "unit",
        "version": "62950c1f4841d07999bebd7c23e33a98f0059a7a7dec13308215c168bc6cb7d5"
    },
    "linearsolvers.LinSolve.track_error_Anorm": {
        "code": "class LinSolve:\n    def track_error_Anorm(self, linsys, dim):\n        diff = self.linsys.solution - self.xhat.mean\n        return np.sqrt(np.inner(diff, self.linsys.A @ diff))\n\n    def setup(self, linsys, dim):\n        self.linsys = get_linear_system(name=linsys, dim=dim)\n        xhat, _, _, _ = problinsolve(A=self.linsys.A, b=self.linsys.b)\n        self.xhat = xhat",
        "name": "linearsolvers.LinSolve.track_error_Anorm",
        "param_names": [
            "linsys",
            "dim"
        ],
        "params": [
            [
                "'dense'",
                "'sparse'",
                "'linop'"
            ],
            [
                "100",
                "1000",
                "10000",
                "100000"
            ]
        ],
        "timeout": 60.0,
        "type": "track",
        "unit": "unit",
        "version": "5f36841f0f7a7c6b0f61024b458950fccc82e2de80f1ee449550409b1be54335"
    },
    "linearsolvers.LinSolve.track_residual_norm": {
        "code": "class LinSolve:\n    def track_residual_norm(self, linsys, dim):\n        return np.linalg.norm(self.linsys.A @ self.xhat.mean - self.linsys.b)\n\n    def setup(self, linsys, dim):\n        self.linsys = get_linear_system(name=linsys, dim=dim)\n        xhat, _, _, _ = problinsolve(A=self.linsys.A, b=self.linsys.b)\n        self.xhat = xhat",
        "name": "linearsolvers.LinSolve.track_residual_norm",
        "param_names": [
            "linsys",
            "dim"
        ],
        "params": [
            [
                "'dense'",
                "'sparse'",
                "'linop'"
            ],
            [
                "100",
                "1000",
                "10000",
                "100000"
            ]
        ],
        "timeout": 60.0,
        "type": "track",
        "unit": "unit",
        "version": "518f263f8ed43bd7f935e933bc4b2ac101616e2d303f9a44c3129374070dcc48"
    },
    "linearsolvers.PosteriorBelief.peakmem_trace_cov": {
        "code": "class PosteriorBelief:\n    def peakmem_trace_cov(self, linsys, dim, qoi):\n        self.qoi.cov.trace()\n\n    def setup(self, linsys, dim, qoi):\n    \n        if dim > 1000:\n            # Operations on the posterior for large matrices can be very memory intensive.\n            raise NotImplementedError()\n    \n        self.linsys = get_linear_system(name=linsys, dim=dim)\n        x, A, Ainv, _ = problinsolve(A=self.linsys.A, b=self.linsys.b)\n        self.qoi = get_quantity_of_interest(qoi, x, A, Ainv)",
        "name": "linearsolvers.PosteriorBelief.peakmem_trace_cov",
        "param_names": [
            "linsys",
            "dim",
            "qoi"
        ],
        "params": [
            [
                "'dense'",
                "'sparse'",
                "'linop'"
            ],
            [
                "100",
                "1000",
                "10000",
                "100000"
            ],
            [
                "'x'",
                "'A'",
                "'Ainv'"
            ]
        ],
        "timeout": 60.0,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "e25b9c45f357edb297758e211da0c31cb63da0523370679774072fd3d6a6d387"
    },
    "linearsolvers.PosteriorBelief.time_trace_cov": {
        "code": "class PosteriorBelief:\n    def time_trace_cov(self, linsys, dim, qoi):\n        self.qoi.cov.trace()\n\n    def setup(self, linsys, dim, qoi):\n    \n        if dim > 1000:\n            # Operations on the posterior for large matrices can be very memory intensive.\n            raise NotImplementedError()\n    \n        self.linsys = get_linear_system(name=linsys, dim=dim)\n        x, A, Ainv, _ = problinsolve(A=self.linsys.A, b=self.linsys.b)\n        self.qoi = get_quantity_of_interest(qoi, x, A, Ainv)",
        "min_run_count": 2,
        "name": "linearsolvers.PosteriorBelief.time_trace_cov",
        "number": 0,
        "param_names": [
            "linsys",
            "dim",
            "qoi"
        ],
        "params": [
            [
                "'dense'",
                "'sparse'",
                "'linop'"
            ],
            [
                "100",
                "1000",
                "10000",
                "100000"
            ],
            [
                "'x'",
                "'A'",
                "'Ainv'"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "2462d533c7254a2600be1fb1ffce2b74104920b18a493224f71db7c05bf7ae92",
        "warmup_time": -1
    },
    "linops.Cond.peakmem_cond": {
        "code": "class Cond:\n    def peakmem_cond(self, operator: str, p):\n        self.linop.cond(p=p)\n\n    def setup(self, operator: str, p):\n        np.random.seed(42)\n    \n        if operator in NO_COND[p]:\n            raise NotImplementedError()\n    \n        self.linop = get_linear_operator(operator)",
        "name": "linops.Cond.peakmem_cond",
        "param_names": [
            "operator",
            "p"
        ],
        "params": [
            [
                "'matrix'",
                "'matrix_sparse'",
                "'identity'",
                "'isotropic_scaling'",
                "'anisotropic_scaling'",
                "'kronecker'",
                "'symmetric_kronecker_distinct_factors'",
                "'symmetric_kronecker_identical_factors'"
            ],
            [
                "2",
                "'fro'",
                "1",
                "inf"
            ]
        ],
        "timeout": 60.0,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "de1c7de85ed1e087b13267ea364dcb4cd32dba38932bed7f4a2c0882a7eb2eee"
    },
    "linops.Cond.time_cond": {
        "code": "class Cond:\n    def time_cond(self, operator: str, p):\n        self.linop.cond(p=p)\n\n    def setup(self, operator: str, p):\n        np.random.seed(42)\n    \n        if operator in NO_COND[p]:\n            raise NotImplementedError()\n    \n        self.linop = get_linear_operator(operator)",
        "min_run_count": 2,
        "name": "linops.Cond.time_cond",
        "number": 0,
        "param_names": [
            "operator",
            "p"
        ],
        "params": [
            [
                "'matrix'",
                "'matrix_sparse'",
                "'identity'",
                "'isotropic_scaling'",
                "'anisotropic_scaling'",
                "'kronecker'",
                "'symmetric_kronecker_distinct_factors'",
                "'symmetric_kronecker_identical_factors'"
            ],
            [
                "2",
                "'fro'",
                "1",
                "inf"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "631616ea7ae3a99fc7663f184c65dcaa0cc9d7c676124dd895aef0e527f62dce",
        "warmup_time": -1
    },
    "linops.Construction.peakmem_matvec": {
        "code": "class Construction:\n    def peakmem_matvec(self, operator: str):\n        get_linear_operator(operator)\n\n    def setup(self, operator: str):\n        np.random.seed(42)",
        "name": "linops.Construction.peakmem_matvec",
        "param_names": [
            "operator"
        ],
        "params": [
            [
                "'matrix'",
                "'matrix_sparse'",
                "'identity'",
                "'isotropic_scaling'",
                "'anisotropic_scaling'",
                "'kronecker'",
                "'symmetric_kronecker_distinct_factors'",
                "'symmetric_kronecker_identical_factors'"
            ]
        ],
        "timeout": 60.0,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "ae87a369dcccf6af4c938b268cd8228960e7357b16e4f2fbd91d85b5203d8e7c"
    },
    "linops.Construction.time_construction": {
        "code": "class Construction:\n    def time_construction(self, operator: str):\n        get_linear_operator(operator)\n\n    def setup(self, operator: str):\n        np.random.seed(42)",
        "min_run_count": 2,
        "name": "linops.Construction.time_construction",
        "number": 0,
        "param_names": [
            "operator"
        ],
        "params": [
            [
                "'matrix'",
                "'matrix_sparse'",
                "'identity'",
                "'isotropic_scaling'",
                "'anisotropic_scaling'",
                "'kronecker'",
                "'symmetric_kronecker_distinct_factors'",
                "'symmetric_kronecker_identical_factors'"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "a30599dfc07b2fc54d7dd57b61f6f291d5be098be4561d33c6a4cfe87f727eee",
        "warmup_time": -1
    },
    "linops.Det.peakmem_det": {
        "code": "class Det:\n    def peakmem_det(self, operator: str):\n        self.linop.det()\n\n    def setup(self, operator: str):\n        np.random.seed(42)\n    \n        if operator in NO_DET:\n            raise NotImplementedError()\n    \n        self.linop = get_linear_operator(operator)",
        "name": "linops.Det.peakmem_det",
        "param_names": [
            "operator"
        ],
        "params": [
            [
                "'matrix'",
                "'matrix_sparse'",
                "'identity'",
                "'isotropic_scaling'",
                "'anisotropic_scaling'",
                "'kronecker'",
                "'symmetric_kronecker_distinct_factors'",
                "'symmetric_kronecker_identical_factors'"
            ]
        ],
        "timeout": 60.0,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "0f7b7734cc4aae667f7420eb65bec0e2a8d93ace2b3ea9fcb0843c36db15df16"
    },
    "linops.Det.time_det": {
        "code": "class Det:\n    def time_det(self, operator: str):\n        self.linop.det()\n\n    def setup(self, operator: str):\n        np.random.seed(42)\n    \n        if operator in NO_DET:\n            raise NotImplementedError()\n    \n        self.linop = get_linear_operator(operator)",
        "min_run_count": 2,
        "name": "linops.Det.time_det",
        "number": 0,
        "param_names": [
            "operator"
        ],
        "params": [
            [
                "'matrix'",
                "'matrix_sparse'",
                "'identity'",
                "'isotropic_scaling'",
                "'anisotropic_scaling'",
                "'kronecker'",
                "'symmetric_kronecker_distinct_factors'",
                "'symmetric_kronecker_identical_factors'"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "0c2242d4f54ee8a7e2a11f686e600bfaeeb88693a5f6bc7411c207cbb3790bc1",
        "warmup_time": -1
    },
    "linops.Eigvals.peakmem_eigvals": {
        "code": "class Eigvals:\n    def peakmem_eigvals(self, operator: str):\n        self.linop.eigvals()\n\n    def setup(self, operator: str):\n        np.random.seed(42)\n    \n        if operator in NO_EIGVALS:\n            raise NotImplementedError()\n    \n        self.linop = get_linear_operator(operator)",
        "name": "linops.Eigvals.peakmem_eigvals",
        "param_names": [
            "operator"
        ],
        "params": [
            [
                "'matrix'",
                "'matrix_sparse'",
                "'identity'",
                "'isotropic_scaling'",
                "'anisotropic_scaling'",
                "'kronecker'",
                "'symmetric_kronecker_distinct_factors'",
                "'symmetric_kronecker_identical_factors'"
            ]
        ],
        "timeout": 60.0,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "5e2311b3426897501464fb49abb571222d9019bb1365d1fa2fa43e067c966c82"
    },
    "linops.Eigvals.time_eigvals": {
        "code": "class Eigvals:\n    def time_eigvals(self, operator: str):\n        self.linop.eigvals()\n\n    def setup(self, operator: str):\n        np.random.seed(42)\n    \n        if operator in NO_EIGVALS:\n            raise NotImplementedError()\n    \n        self.linop = get_linear_operator(operator)",
        "min_run_count": 2,
        "name": "linops.Eigvals.time_eigvals",
        "number": 0,
        "param_names": [
            "operator"
        ],
        "params": [
            [
                "'matrix'",
                "'matrix_sparse'",
                "'identity'",
                "'isotropic_scaling'",
                "'anisotropic_scaling'",
                "'kronecker'",
                "'symmetric_kronecker_distinct_factors'",
                "'symmetric_kronecker_identical_factors'"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "2a12534450fb9e4be1b0423e92b87d90d118d53107b12c60535b8819583479b2",
        "warmup_time": -1
    },
    "linops.LogAbsDet.peakmem_logabsdet": {
        "code": "class LogAbsDet:\n    def peakmem_logabsdet(self, operator: str):\n        self.linop.logabsdet()\n\n    def setup(self, operator: str):\n        np.random.seed(42)\n    \n        if operator in NO_LOGABSDET:\n            raise NotImplementedError()\n    \n        self.linop = get_linear_operator(operator)",
        "name": "linops.LogAbsDet.peakmem_logabsdet",
        "param_names": [
            "operator"
        ],
        "params": [
            [
                "'matrix'",
                "'matrix_sparse'",
                "'identity'",
                "'isotropic_scaling'",
                "'anisotropic_scaling'",
                "'kronecker'",
                "'symmetric_kronecker_distinct_factors'",
                "'symmetric_kronecker_identical_factors'"
            ]
        ],
        "timeout": 60.0,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "ff6088730132a29b2e64db868896fed674ecf65fa182e5c6058ac28033d7b895"
    },
    "linops.LogAbsDet.time_logabsdet": {
        "code": "class LogAbsDet:\n    def time_logabsdet(self, operator: str):\n        self.linop.logabsdet()\n\n    def setup(self, operator: str):\n        np.random.seed(42)\n    \n        if operator in NO_LOGABSDET:\n            raise NotImplementedError()\n    \n        self.linop = get_linear_operator(operator)",
        "min_run_count": 2,
        "name": "linops.LogAbsDet.time_logabsdet",
        "number": 0,
        "param_names": [
            "operator"
        ],
        "params": [
            [
                "'matrix'",
                "'matrix_sparse'",
                "'identity'",
                "'isotropic_scaling'",
                "'anisotropic_scaling'",
                "'kronecker'",
                "'symmetric_kronecker_distinct_factors'",
                "'symmetric_kronecker_identical_factors'"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "673ebc1bf2101999d0cfcddf5a345f5e1e566000367d6186ea2117dfe35143a7",
        "warmup_time": -1
    },
    "linops.MatMat.peakmem_matmat": {
        "code": "class MatMat:\n    def peakmem_matmat(self, operator: str):\n        _ = self.linop @ self.mat\n\n    def setup(self, operator: str):\n        np.random.seed(42)\n    \n        self.linop = get_linear_operator(operator)\n        self.mat = np.ones(\n            (self.linop.shape[1], 1000), dtype=self.linop.dtype, order=\"F\"\n        )",
        "name": "linops.MatMat.peakmem_matmat",
        "param_names": [
            "operator"
        ],
        "params": [
            [
                "'matrix'",
                "'matrix_sparse'",
                "'identity'",
                "'isotropic_scaling'",
                "'anisotropic_scaling'",
                "'kronecker'",
                "'symmetric_kronecker_distinct_factors'",
                "'symmetric_kronecker_identical_factors'"
            ]
        ],
        "timeout": 60.0,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "a67815b3c335e81aaf6e577d2c5f75f8f43de98717463b518c6cdfe0ccf72ef6"
    },
    "linops.MatMat.time_matmat": {
        "code": "class MatMat:\n    def time_matmat(self, operator: str):\n        _ = self.linop @ self.mat\n\n    def setup(self, operator: str):\n        np.random.seed(42)\n    \n        self.linop = get_linear_operator(operator)\n        self.mat = np.ones(\n            (self.linop.shape[1], 1000), dtype=self.linop.dtype, order=\"F\"\n        )",
        "min_run_count": 2,
        "name": "linops.MatMat.time_matmat",
        "number": 0,
        "param_names": [
            "operator"
        ],
        "params": [
            [
                "'matrix'",
                "'matrix_sparse'",
                "'identity'",
                "'isotropic_scaling'",
                "'anisotropic_scaling'",
                "'kronecker'",
                "'symmetric_kronecker_distinct_factors'",
                "'symmetric_kronecker_identical_factors'"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "56c6cafbf6cef4adf5006c7a1a0521b50bae2061dd48d6b6c3282747c7bcb0f0",
        "warmup_time": -1
    },
    "linops.MatVec.peakmem_matvec": {
        "code": "class MatVec:\n    def peakmem_matvec(self, operator: str):\n        _ = self.linop @ self.vec\n\n    def setup(self, operator: str):\n        np.random.seed(42)\n    \n        self.linop = get_linear_operator(operator)\n        self.vec = np.ones(self.linop.shape[1], dtype=self.linop.dtype)",
        "name": "linops.MatVec.peakmem_matvec",
        "param_names": [
            "operator"
        ],
        "params": [
            [
                "'matrix'",
                "'matrix_sparse'",
                "'identity'",
                "'isotropic_scaling'",
                "'anisotropic_scaling'",
                "'kronecker'",
                "'symmetric_kronecker_distinct_factors'",
                "'symmetric_kronecker_identical_factors'"
            ]
        ],
        "timeout": 60.0,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "870528f5173e3432055cbaf18a1613f907a2ff2557a5fbdce0b48fa69f0c0065"
    },
    "linops.MatVec.time_matvec": {
        "code": "class MatVec:\n    def time_matvec(self, operator: str):\n        _ = self.linop @ self.vec\n\n    def setup(self, operator: str):\n        np.random.seed(42)\n    \n        self.linop = get_linear_operator(operator)\n        self.vec = np.ones(self.linop.shape[1], dtype=self.linop.dtype)",
        "min_run_count": 2,
        "name": "linops.MatVec.time_matvec",
        "number": 0,
        "param_names": [
            "operator"
        ],
        "params": [
            [
                "'matrix'",
                "'matrix_sparse'",
                "'identity'",
                "'isotropic_scaling'",
                "'anisotropic_scaling'",
                "'kronecker'",
                "'symmetric_kronecker_distinct_factors'",
                "'symmetric_kronecker_identical_factors'"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "cd9c1dd865449e5810e461b20ca04b8d8bc53c21ca294bda571d2645afece784",
        "warmup_time": -1
    },
    "linops.Rank.peakmem_rank": {
        "code": "class Rank:\n    def peakmem_rank(self, operator: str):\n        self.linop.rank()\n\n    def setup(self, operator: str):\n        np.random.seed(42)\n    \n        if operator in NO_RANK:\n            raise NotImplementedError()\n    \n        self.linop = get_linear_operator(operator)",
        "name": "linops.Rank.peakmem_rank",
        "param_names": [
            "operator"
        ],
        "params": [
            [
                "'matrix'",
                "'matrix_sparse'",
                "'identity'",
                "'isotropic_scaling'",
                "'anisotropic_scaling'",
                "'kronecker'",
                "'symmetric_kronecker_distinct_factors'",
                "'symmetric_kronecker_identical_factors'"
            ]
        ],
        "timeout": 60.0,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "a936825e1c63c8e988eddadac78ef6b3fe26a92aacf25a17915ee1bcf0cf7758"
    },
    "linops.Rank.time_rank": {
        "code": "class Rank:\n    def time_rank(self, operator: str):\n        self.linop.rank()\n\n    def setup(self, operator: str):\n        np.random.seed(42)\n    \n        if operator in NO_RANK:\n            raise NotImplementedError()\n    \n        self.linop = get_linear_operator(operator)",
        "min_run_count": 2,
        "name": "linops.Rank.time_rank",
        "number": 0,
        "param_names": [
            "operator"
        ],
        "params": [
            [
                "'matrix'",
                "'matrix_sparse'",
                "'identity'",
                "'isotropic_scaling'",
                "'anisotropic_scaling'",
                "'kronecker'",
                "'symmetric_kronecker_distinct_factors'",
                "'symmetric_kronecker_identical_factors'"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "c2e4bd0b1fffac9da7371c0a548285b8966878da14c48b3549fd4a674f4d15b0",
        "warmup_time": -1
    },
    "linops.Trace.peakmem_trace": {
        "code": "class Trace:\n    def peakmem_trace(self, operator: str):\n        self.linop.trace()\n\n    def setup(self, operator: str):\n        np.random.seed(42)\n    \n        if operator in NO_TRACE:\n            raise NotImplementedError()\n    \n        self.linop = get_linear_operator(operator)",
        "name": "linops.Trace.peakmem_trace",
        "param_names": [
            "operator"
        ],
        "params": [
            [
                "'matrix'",
                "'matrix_sparse'",
                "'identity'",
                "'isotropic_scaling'",
                "'anisotropic_scaling'",
                "'kronecker'",
                "'symmetric_kronecker_distinct_factors'",
                "'symmetric_kronecker_identical_factors'"
            ]
        ],
        "timeout": 60.0,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "396ce90079c28a6a9c124c215a13a4cfe6b980dc09f35fc4ff4079af1353c5fd"
    },
    "linops.Trace.time_trace": {
        "code": "class Trace:\n    def time_trace(self, operator: str):\n        self.linop.trace()\n\n    def setup(self, operator: str):\n        np.random.seed(42)\n    \n        if operator in NO_TRACE:\n            raise NotImplementedError()\n    \n        self.linop = get_linear_operator(operator)",
        "min_run_count": 2,
        "name": "linops.Trace.time_trace",
        "number": 0,
        "param_names": [
            "operator"
        ],
        "params": [
            [
                "'matrix'",
                "'matrix_sparse'",
                "'identity'",
                "'isotropic_scaling'",
                "'anisotropic_scaling'",
                "'kronecker'",
                "'symmetric_kronecker_distinct_factors'",
                "'symmetric_kronecker_identical_factors'"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "ccb41a2f40430f0a7ab8e86147d9d890a75858e4828034dea3863de3714e8a50",
        "warmup_time": -1
    },
    "random_variables.Functions.time_distr_functions": {
        "code": "class Functions:\n    def time_distr_functions(self, randvar, method):\n        \"\"\"Times evaluation of the pdf, logpdf, cdf and logcdf.\"\"\"\n        try:\n            if method == \"pdf\":\n                self.randvar.pdf(x=self.eval_point)\n            elif method == \"logpdf\":\n                self.randvar.logpdf(x=self.eval_point)\n            elif method == \"cdf\":\n                self.randvar.cdf(x=self.quantile)\n            elif method == \"logcdf\":\n                self.randvar.logcdf(x=self.quantile)\n        except NotImplementedError:\n            pass\n\n    def setup(self, randvar, method):\n        self.randvar = get_randvar(rv_name=randvar)\n        self.eval_point = np.random.uniform(size=self.randvar.shape)\n        self.quantile = np.random.uniform(size=self.randvar.shape)",
        "min_run_count": 2,
        "name": "random_variables.Functions.time_distr_functions",
        "number": 0,
        "param_names": [
            "randvar",
            "method"
        ],
        "params": [
            [
                "'univar_normal'",
                "'multivar_normal'",
                "'matrixvar_normal'",
                "'symmatrixvar_normal'",
                "'operatorvar_normal'"
            ],
            [
                "'pdf'",
                "'logpdf'",
                "'cdf'",
                "'logcdf'"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "7e411912776b427b31a26b16d9bb33e49fba6bef3e1d49b79641f7b2138e2ff9",
        "warmup_time": -1
    },
    "random_variables.Sampling.peakmem_sample": {
        "code": "class Sampling:\n    def peakmem_sample(self, randvar):\n        \"\"\"Peak memory of sampling process.\"\"\"\n        self.randvar.sample(rng=self.rng, size=self.n_samples)\n\n    def setup(self, randvar):\n        self.rng = np.random.default_rng(seed=2)\n        self.n_samples = 1000\n        self.randvar = get_randvar(rv_name=randvar)",
        "name": "random_variables.Sampling.peakmem_sample",
        "param_names": [
            "randvar"
        ],
        "params": [
            [
                "'univar_normal'",
                "'multivar_normal'",
                "'matrixvar_normal'",
                "'symmatrixvar_normal'",
                "'operatorvar_normal'"
            ]
        ],
        "timeout": 60.0,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "72376cccbe83a44cfd4b5e88d92a9aee5272707272d5973dd08d5c285aba36b8"
    },
    "random_variables.Sampling.time_sample": {
        "code": "class Sampling:\n    def time_sample(self, randvar):\n        \"\"\"Times sampling from this distribution.\"\"\"\n        self.randvar.sample(rng=self.rng, size=self.n_samples)\n\n    def setup(self, randvar):\n        self.rng = np.random.default_rng(seed=2)\n        self.n_samples = 1000\n        self.randvar = get_randvar(rv_name=randvar)",
        "min_run_count": 2,
        "name": "random_variables.Sampling.time_sample",
        "number": 0,
        "param_names": [
            "randvar"
        ],
        "params": [
            [
                "'univar_normal'",
                "'multivar_normal'",
                "'matrixvar_normal'",
                "'symmatrixvar_normal'",
                "'operatorvar_normal'"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "0e88b17462e8804ae5a3f1212d88ccb36de4d62d11e9e5bdf6137c30e7a8a127",
        "warmup_time": -1
    },
    "randprocs.MarkovProcessSampling.time_sample": {
        "code": "class MarkovProcessSampling:\n    def time_sample(self, lazy_linalg, len_trajectory, num_derivatives, dimension):\n        with config(lazy_linalg=lazy_linalg):\n            self.markov_process.transition.jointly_transform_base_measure_realization_list_forward(\n                base_measure_realizations=self.base_measure_realization,\n                t=self.time_grid,\n                initrv=self.markov_process.initrv,\n                _diffusion_list=np.ones_like(self.time_grid[:-1]),\n            )\n\n    def setup(self, lazy_linalg, len_trajectory, num_derivatives, dimension):\n        with config(lazy_linalg=lazy_linalg):\n    \n            dynamics = randprocs.markov.integrator.IntegratedWienerTransition(\n                num_derivatives=num_derivatives,\n                wiener_process_dimension=dimension,\n                forward_implementation=\"classic\",\n                backward_implementation=\"classic\",\n            )\n    \n            measvar = 0.1024\n            initrv = randvars.Normal(\n                np.ones(dynamics.state_dimension),\n                measvar * linops.Identity(dynamics.state_dimension),\n            )\n    \n            time_domain = (0.0, float(len_trajectory))\n            self.time_grid = np.arange(*time_domain)\n            self.markov_process = randprocs.markov.MarkovProcess(\n                initarg=time_domain[0], initrv=initrv, transition=dynamics\n            )\n    \n            rng = np.random.default_rng(seed=1)\n            self.base_measure_realization = scipy.stats.norm.rvs(\n                size=(self.time_grid.shape + initrv.shape),\n                random_state=rng,\n            )",
        "min_run_count": 2,
        "name": "randprocs.MarkovProcessSampling.time_sample",
        "number": 0,
        "param_names": [
            "lazy_linalg",
            "len_trajectory",
            "num_derivatives",
            "dimension"
        ],
        "params": [
            [
                "True",
                "False"
            ],
            [
                "10"
            ],
            [
                "5"
            ],
            [
                "50",
                "100"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "d1aeaee748493c4f32a4840f5e0d29583124e22358505eea3c3b73781d0ac2ba",
        "warmup_time": -1
    },
    "version": 2
}