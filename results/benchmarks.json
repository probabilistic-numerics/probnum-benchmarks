{
    "ivpsolvers.IVPSolve.peakmem_solve": {
        "code": "class IVPSolve:\n    def peakmem_solve(self, method, precond, prior):\n        precond_step = self.stepsize if precond == \"with\" else 1.0\n        probsolve_ivp(\n            self.ivp,\n            method=method,\n            which_prior=prior,\n            step=self.stepsize,\n            precond_step=precond_step,\n        )\n\n    def setup(self, method, precond, prior):\n        # pylint: disable=invalid-name\n        self.ivp = load_lotkavolterra()\n        self.stepsize = 1e-2",
        "name": "ivpsolvers.IVPSolve.peakmem_solve",
        "param_names": [
            "method",
            "precond",
            "prior"
        ],
        "params": [
            [
                "'eks0'",
                "'ekf0'"
            ],
            [
                "'with'",
                "'without'"
            ],
            [
                "'ibm4'",
                "'ioup4'",
                "'matern92'"
            ]
        ],
        "timeout": 60.0,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "aa83f1ed946d1379af131e830cc08e7443079e555ada6642d9f6358d522ecc12"
    },
    "ivpsolvers.IVPSolve.time_solve": {
        "code": "class IVPSolve:\n    def time_solve(self, method, precond, prior):\n        precond_step = self.stepsize if precond == \"with\" else 1.0\n        probsolve_ivp(\n            self.ivp,\n            method=method,\n            which_prior=prior,\n            step=self.stepsize,\n            precond_step=precond_step,\n        )\n\n    def setup(self, method, precond, prior):\n        # pylint: disable=invalid-name\n        self.ivp = load_lotkavolterra()\n        self.stepsize = 1e-2",
        "min_run_count": 2,
        "name": "ivpsolvers.IVPSolve.time_solve",
        "number": 0,
        "param_names": [
            "method",
            "precond",
            "prior"
        ],
        "params": [
            [
                "'eks0'",
                "'ekf0'"
            ],
            [
                "'with'",
                "'without'"
            ],
            [
                "'ibm4'",
                "'ioup4'",
                "'matern92'"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "3b5cc12036e423afc0e5e7294286264a20fbd2fbe7bfb8711d080cd88ef67543",
        "warmup_time": -1
    },
    "kernels.Kernels.peakmem_kernel_matrix": {
        "code": "class Kernels:\n    def peakmem_kernel_matrix(self, kernel, n_datapoints):\n        \"\"\"Peak memory of sampling process.\"\"\"\n        self.kernel(self.data)\n\n    def setup(self, kernel, n_datapoints):\n        rng = np.random.default_rng(42)\n        self.input_dim = 100\n        self.data = rng.normal(size=(n_datapoints, self.input_dim))\n        self.kernel = get_kernel(kernel_name=kernel, input_dim=self.input_dim)",
        "name": "kernels.Kernels.peakmem_kernel_matrix",
        "param_names": [
            "kernel",
            "n_datapoints"
        ],
        "params": [
            [
                "'white_noise'",
                "'linear'",
                "'polynomial'",
                "'exp_quad'",
                "'rat_quad'",
                "'matern12'",
                "'matern32'",
                "'matern52'",
                "'matern72'"
            ],
            [
                "10",
                "100",
                "1000"
            ]
        ],
        "timeout": 60.0,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "b4f420e1ef1214a865c6f026feb39a43143f57a26b361623fb63418e2f0a01b1"
    },
    "kernels.Kernels.time_kernel_matrix": {
        "code": "class Kernels:\n    def time_kernel_matrix(self, kernel, n_datapoints):\n        \"\"\"Times sampling from this distribution.\"\"\"\n        self.kernel(self.data)\n\n    def setup(self, kernel, n_datapoints):\n        rng = np.random.default_rng(42)\n        self.input_dim = 100\n        self.data = rng.normal(size=(n_datapoints, self.input_dim))\n        self.kernel = get_kernel(kernel_name=kernel, input_dim=self.input_dim)",
        "min_run_count": 2,
        "name": "kernels.Kernels.time_kernel_matrix",
        "number": 0,
        "param_names": [
            "kernel",
            "n_datapoints"
        ],
        "params": [
            [
                "'white_noise'",
                "'linear'",
                "'polynomial'",
                "'exp_quad'",
                "'rat_quad'",
                "'matern12'",
                "'matern32'",
                "'matern52'",
                "'matern72'"
            ],
            [
                "10",
                "100",
                "1000"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "bd80bb62c96bc059c77c591c8a2f9c501cce5fe29dd92efb750ce55f0ada226e",
        "warmup_time": -1
    },
    "linearsolvers.LinSolve.mem_solve": {
        "code": "class LinSolve:\n    def mem_solve(self, system):\n        \"\"\"Time solving a linear system.\"\"\"\n        problinsolve(A=self.A, b=self.b)\n\n    def setup(self, system):\n        # Seed\n        np.random.seed(42)\n    \n        if system == \"sparse\":\n            (\n                self.A,\n                self.b,\n            ) = load_poisson_linear_system()\n        elif system == \"dense\":\n            self.A = SPD_MATRIX_5x5\n            self.b = np.random.normal(size=self.A.shape[0])\n        elif system == \"large-scale\":\n            self.A = None\n            self.b = None",
        "name": "linearsolvers.LinSolve.mem_solve",
        "param_names": [
            "system"
        ],
        "params": [
            [
                "'sparse'",
                "'dense'"
            ]
        ],
        "timeout": 60.0,
        "type": "memory",
        "unit": "bytes",
        "version": "339b33f3828c63a96101d46a5fc0516e96c6493bd4c7299a1d1de5ae414517ff"
    },
    "linearsolvers.LinSolve.peakmem_solve": {
        "code": "class LinSolve:\n    def peakmem_solve(self, system):\n        \"\"\"Time solving a linear system.\"\"\"\n        problinsolve(A=self.A, b=self.b)\n\n    def setup(self, system):\n        # Seed\n        np.random.seed(42)\n    \n        if system == \"sparse\":\n            (\n                self.A,\n                self.b,\n            ) = load_poisson_linear_system()\n        elif system == \"dense\":\n            self.A = SPD_MATRIX_5x5\n            self.b = np.random.normal(size=self.A.shape[0])\n        elif system == \"large-scale\":\n            self.A = None\n            self.b = None",
        "name": "linearsolvers.LinSolve.peakmem_solve",
        "param_names": [
            "system"
        ],
        "params": [
            [
                "'sparse'",
                "'dense'"
            ]
        ],
        "timeout": 60.0,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "6647c7e69e7c7de96befd7f8e9df8d0cbef4865c223a4c915786b12c84cb92c2"
    },
    "linearsolvers.LinSolve.time_solve": {
        "code": "class LinSolve:\n    def time_solve(self, system):\n        \"\"\"Time solving a linear system.\"\"\"\n        problinsolve(A=self.A, b=self.b)\n\n    def setup(self, system):\n        # Seed\n        np.random.seed(42)\n    \n        if system == \"sparse\":\n            (\n                self.A,\n                self.b,\n            ) = load_poisson_linear_system()\n        elif system == \"dense\":\n            self.A = SPD_MATRIX_5x5\n            self.b = np.random.normal(size=self.A.shape[0])\n        elif system == \"large-scale\":\n            self.A = None\n            self.b = None",
        "min_run_count": 2,
        "name": "linearsolvers.LinSolve.time_solve",
        "number": 0,
        "param_names": [
            "system"
        ],
        "params": [
            [
                "'sparse'",
                "'dense'"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "00e14040e21d8eb565e633cf998a4aa266616e92f9a884480a4cb8dd4050545a",
        "warmup_time": -1
    },
    "linearsolvers.PosteriorDist.time_sample": {
        "code": "class PosteriorDist:\n    def time_sample(self, output):\n        \"\"\"Time sampling from the posterior distribution.\"\"\"\n        if output == \"solution\":\n            self.xhat.sample(self.n_samples)\n        elif output == \"matrix\":\n            self.Ahat.sample(self.n_samples)\n        elif output == \"matrix_inverse\":\n            self.Ainvhat.sample(self.n_samples)\n\n    def setup(self, output):\n        # pylint: disable=invalid-name\n    \n        # Sparse system\n        self.A, self.b = load_poisson_linear_system()\n    \n        # Solve linear system\n        self.xhat, self.Ahat, self.Ainvhat, _ = problinsolve(A=self.A, b=self.b)\n    \n        # Benchmark parameters\n        self.n_samples = 10",
        "min_run_count": 2,
        "name": "linearsolvers.PosteriorDist.time_sample",
        "number": 0,
        "param_names": [
            "output"
        ],
        "params": [
            [
                "'solution'",
                "'matrix'",
                "'matrix_inverse'"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "da540442fa5cdd201a5b76df0ad91f4ffcd4c63dee83a54c466fe9079ff0ef4d",
        "warmup_time": -1
    },
    "random_variables.Functions.time_distr_functions": {
        "code": "class Functions:\n    def time_distr_functions(self, randvar, method):\n        \"\"\"Times evaluation of the pdf, logpdf, cdf and logcdf.\"\"\"\n        try:\n            if method == \"pdf\":\n                self.randvar.pdf(x=self.eval_point)\n            elif method == \"logpdf\":\n                self.randvar.logpdf(x=self.eval_point)\n            elif method == \"cdf\":\n                self.randvar.cdf(x=self.quantile)\n            elif method == \"logcdf\":\n                self.randvar.logcdf(x=self.quantile)\n        except NotImplementedError:\n            pass\n\n    def setup(self, randvar, method):\n        self.randvar = get_randvar(rv_name=randvar)\n        self.eval_point = np.random.uniform(size=self.randvar.shape)\n        self.quantile = np.random.uniform(size=self.randvar.shape)",
        "min_run_count": 2,
        "name": "random_variables.Functions.time_distr_functions",
        "number": 0,
        "param_names": [
            "randvar",
            "method"
        ],
        "params": [
            [
                "'univar_normal'",
                "'multivar_normal'",
                "'matrixvar_normal'",
                "'symmatrixvar_normal'",
                "'operatorvar_normal'"
            ],
            [
                "'pdf'",
                "'logpdf'",
                "'cdf'",
                "'logcdf'"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "7e411912776b427b31a26b16d9bb33e49fba6bef3e1d49b79641f7b2138e2ff9",
        "warmup_time": -1
    },
    "random_variables.Sampling.peakmem_sample": {
        "code": "class Sampling:\n    def peakmem_sample(self, randvar):\n        \"\"\"Peak memory of sampling process.\"\"\"\n        self.randvar.sample(self.n_samples)\n\n    def setup(self, randvar):\n        np.random.seed(42)\n        self.n_samples = 1000\n        self.randvar = get_randvar(rv_name=randvar)",
        "name": "random_variables.Sampling.peakmem_sample",
        "param_names": [
            "randvar"
        ],
        "params": [
            [
                "'univar_normal'",
                "'multivar_normal'",
                "'matrixvar_normal'",
                "'symmatrixvar_normal'",
                "'operatorvar_normal'"
            ]
        ],
        "timeout": 60.0,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "8c7bfdb1e4a4015a16a3a6d46e1f74176aef0e16995f157e92bdbf632c6326d1"
    },
    "random_variables.Sampling.time_sample": {
        "code": "class Sampling:\n    def time_sample(self, randvar):\n        \"\"\"Times sampling from this distribution.\"\"\"\n        self.randvar.sample(self.n_samples)\n\n    def setup(self, randvar):\n        np.random.seed(42)\n        self.n_samples = 1000\n        self.randvar = get_randvar(rv_name=randvar)",
        "min_run_count": 2,
        "name": "random_variables.Sampling.time_sample",
        "number": 0,
        "param_names": [
            "randvar"
        ],
        "params": [
            [
                "'univar_normal'",
                "'multivar_normal'",
                "'matrixvar_normal'",
                "'symmatrixvar_normal'",
                "'operatorvar_normal'"
            ]
        ],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "27dbfe7ba451737d64221100d07633db8df65f4992b6dc037ff7e395fbbf4697",
        "warmup_time": -1
    },
    "version": 2
}